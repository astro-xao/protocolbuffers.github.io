<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 参考 on Protocol Buffers 文档 (由 GPT-4.1 翻译)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/</link><description>Recent content in Go 参考 on Protocol Buffers 文档 (由 GPT-4.1 翻译)</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/reference/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 生成代码指南（Open）</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated/</guid><description>proto2 和 proto3 生成代码的差异已高亮标注——注意，这些差异仅体现在本文档描述的生成代码中，基础 API 在两个版本中是相同的。建议在阅读本文档前，先阅读 proto2 语言指南 和/或 proto3 语言指南。
注意 您正在查看旧版生成代码 API（Open Struct API）的文档。 参见 Go 生成代码（Opaque） 获取新版 Opaque API 的相关文档。Opaque API 的介绍请见 Go Protobuf: The new Opaque API。 编译器调用 Protocol Buffer 编译器需要插件来生成 Go 代码。使用 Go 1.16 或更高版本，运行以下命令安装：
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 这将在 $GOBIN 目录下安装 protoc-gen-go 可执行文件。可通过设置 $GOBIN 环境变量更改安装位置。该目录需加入您的 $PATH，以便编译器找到插件。
编译器通过 go_out 标志生成 Go 输出。该标志的参数为输出目录。每个输入的 .proto 文件会生成一个源文件，输出文件名将 .proto 后缀替换为 .pb.go。
生成的 .pb.go 文件在输出目录中的位置取决于编译器参数，有以下几种模式：
指定 paths=import 时，输出文件放在以 Go 包导入路径命名的目录下（如 .proto 文件中的 go_package 选项）。例如，输入文件 protos/buzz.</description></item><item><title>Go 生成代码指南（Opaque）</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated-opaque/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated-opaque/</guid><description>proto2 和 proto3 生成代码的任何差异都会被高亮标注——请注意，这些差异仅体现在本文档描述的生成代码中，基础 API 在两个版本中是相同的。建议在阅读本文档前，先阅读 proto2 语言指南 和/或 proto3 语言指南。
注意 您正在查看 Opaque API 的文档，这是当前版本。如果您正在处理使用旧版 Open Struct API 的 .proto 文件（可通过 .proto 文件中的 API level 设置判断），请参阅 Go 生成代码（Open） 获取相应文档。Opaque API 的介绍见 Go Protobuf: The new Opaque API。 编译器调用 Protocol Buffer 编译器需要插件来生成 Go 代码。使用 Go 1.16 或更高版本，运行以下命令安装：
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 这将在 $GOBIN 目录下安装 protoc-gen-go 二进制文件。通过设置 $GOBIN 环境变量可更改安装位置。该目录必须在您的 $PATH 中，以便编译器找到它。
编译器通过 go_out 标志生成 Go 输出。该标志的参数为您希望编译器写入 Go 输出的目录。每个输入的 .proto 文件会生成一个源文件，输出文件名为将 .proto 扩展名替换为 .</description></item><item><title>Go 常见问题</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/faq/</guid><description>版本 github.com/golang/protobuf 和 google.golang.org/protobuf 有什么区别？ github.com/golang/protobuf 模块是最初的 Go Protocol Buffers API。
google.golang.org/protobuf 模块是该 API 的更新版本，设计更简洁、易用且安全。新版 API 的主要特性包括反射支持，以及将用户接口与底层实现分离。
我们建议新代码使用 google.golang.org/protobuf。
github.com/golang/protobuf 的 v1.4.0 及更高版本会封装新实现，允许程序逐步采用新 API。例如，github.com/golang/protobuf/ptypes 中定义的知名类型只是新模块中类型的别名。因此，google.golang.org/protobuf/types/known/emptypb 和 github.com/golang/protobuf/ptypes/empty 可以互换使用。
什么是 proto1、proto2 和 proto3？ 这些是 Protocol Buffers 语言 的不同版本，与 Go 的 实现 无关。
proto3 是当前的语言版本，也是最常用的版本。我们建议新代码使用 proto3。 proto2 是较早的版本，虽然已被 proto3 取代，但仍然完全支持。 proto1 是已废弃的版本，从未开源。 有多个 Message 类型，我该用哪个？ &amp;quot;google.golang.org/protobuf/proto&amp;quot;.Message 是当前 Protocol Buffers 编译器生成的所有消息实现的接口类型。用于操作任意消息的函数（如 proto.Marshal 或 proto.Clone）接受或返回此类型。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.Message 是描述消息反射视图的接口类型。
可通过 proto.Message 的 ProtoReflect 方法获得 protoreflect.Message。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.ProtoMessage 是 &amp;quot;google.</description></item><item><title>Go Size 语义</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/size/</guid><description>proto.Size 函数通过遍历 proto.Message 的所有字段（包括子消息），返回其线格式编码的字节大小。
特别地，它返回的是Go Protobuf 如何编码该消息时的大小。
典型用法 判断消息是否为空 检查 proto.Size 是否返回 0， 是识别空消息的简单方法：
if proto.Size(m) == 0 { // 没有设置字段（或在 proto3 中，所有字段都为默认值）； // 跳过处理该消息，或返回错误等。 } 限制程序输出的大小 假设你正在编写一个批处理管道，用于生成工作任务，交给下游系统处理。 下游系统适合处理小到中等规模的任务，但负载测试显示，当任务超过 500 MB 时， 系统会出现级联故障。
最佳做法是为下游系统增加保护（参见 https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons）， 但如果无法实现负载卸载，可以在管道中添加一个快速修复：
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) &amp;gt; 500 * 1024 * 1024 { // 跳过所有超过 500 MB 的任务，避免压垮脆弱的下游系统。 return } emit(task) } 错误用法：与 Unmarshal 无关 由于 proto.</description></item><item><title>Go API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/api-docs-link/</guid><description/></item><item><title>Go Opaque API 迁移</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration/</guid><description>Opaque API 是 Protocol Buffers 针对 Go 编程语言的最新实现版本。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: Releasing the Opaque API 博客文章以了解介绍。
迁移到 Opaque API 是逐步进行的，可以按每个 proto 消息或每个 .proto 文件进行，通过设置 Protobuf Editions 功能的 api_level 选项为以下值之一：
API_OPEN 选择 Open Struct API；这是 2024 年 12 月之前的唯一 API。 API_HYBRID 是 Open 和 Opaque 之间的过渡：Hybrid API 也包含访问器方法（便于你更新代码），但仍然像以前一样导出结构体字段。性能没有差异；此 API 级别仅用于迁移。 API_OPAQUE 选择 Opaque API。 目前，默认值为 API_OPEN，但即将发布的 Protobuf Edition 2024 将默认值更改为 API_OPAQUE。
要在 Edition 2024 之前使用 Opaque API，请如下设置 api_level：
edition = &amp;#34;2023&amp;#34;; package log; import &amp;#34;google/protobuf/go_features.</description></item><item><title>Go Opaque API：手动迁移</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration-manual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration-manual/</guid><description>Opaque API 是 Protocol Buffers 在 Go 语言中的最新实现。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: Releasing the Opaque API 博客文章以了解简介。
本文档为将 Go Protobuf 用法从旧的 Open Struct API 迁移到新的 Opaque API 的用户指南。
警告 您正在查看手动迁移指南。通常建议使用 open2opaque 工具自动迁移。请参阅 Opaque API 迁移 获取更多信息。 生成代码指南 提供了更多细节。本文将新旧 API 进行对比。
消息构造 假设有如下 protobuf 消息定义：
message Foo { uint32 uint32 = 1; bytes bytes = 2; oneof union { string string = 4; MyMessage message = 5; } enum Kind { … }; Kind kind = 9; } 以下是如何从字面值构造该消息的示例：</description></item><item><title>Go Opaque API 常见问题解答</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-faq/</guid><description>Opaque API 是 Protocol Buffers 针对 Go 语言实现的最新版本。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: The new Opaque API 博客文章以了解介绍。
本常见问题解答回答了关于新 API 及迁移过程中的常见问题。
创建新的 .proto 文件时应使用哪个 API？ 我们建议新开发选择 Opaque API。Protobuf Edition 2024（参见 Protobuf Editions 概览）将使 Opaque API 成为默认选项。
如何为我的消息启用新的 Opaque API？ 在 Protobuf Edition 2023（撰写时为当前版本）中，可以通过在 .proto 文件中将 api_level editions 特性设置为 API_OPAQUE 来选择 Opaque API。可以按文件或按消息设置：
edition = &amp;#34;2023&amp;#34;; package log; import &amp;#34;google/protobuf/go_features.proto&amp;#34;; option features.(pb.go).api_level = API_OPAQUE; message LogEntry { … } Protobuf Edition 2024 将默认使用 Opaque API，届时无需额外导入或选项：</description></item></channel></rss>