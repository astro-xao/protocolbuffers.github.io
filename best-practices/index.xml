<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Proto 最佳实践 on Protocol Buffers 文档</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/</link><description>Recent content in Proto 最佳实践 on Protocol Buffers 文档</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/best-practices/index.xml" rel="self" type="application/rss+xml"/><item><title>Proto 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/dos-donts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/dos-donts/</guid><description>客户端和服务端永远不会在完全相同的时间更新——即使你尝试同时更新它们。某一方可能会被回滚。不要假设你可以做破坏性更改，并且客户端和服务端会保持同步。
不要重复使用标签号 绝不要重复使用标签号。这会导致反序列化出错。即使你认为没有人在用该字段，也不要重复使用标签号。如果更改曾经上线过，可能在某些日志中还存在序列化的 proto 版本。或者在其他服务器上的旧代码会因此崩溃。
要为已删除字段保留标签号 当你删除一个不再使用的字段时，应该保留其标签号，防止将来被误用。只需 reserved 2, 3; 即可，无需指定类型（这样还能减少依赖！）。你也可以保留名称，避免回收已删除的字段名：reserved &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;;。
要为已删除枚举值保留编号 当你删除一个不再使用的枚举值时，应该保留其编号，防止将来被误用。只需 reserved 2, 3; 即可。你也可以保留名称，避免回收已删除的值名：reserved &amp;quot;FOO&amp;quot;, &amp;quot;BAR&amp;quot;;。
要将新的枚举别名放在最后 添加新的枚举别名时，应将新名称放在最后，以便服务有时间更新。
如果要安全地移除原始名称（如果它被用于数据交换，实际上不推荐），你必须执行以下步骤：
在旧名称下方添加新名称，并弃用旧名称（序列化器仍会使用旧名称） 所有解析器都升级后，交换两个名称的顺序（序列化器开始使用新名称，解析器接受两者） 所有序列化器都升级后，可以删除已弃用的名称。 注意： 理论上客户端不应使用旧名称进行数据交换，但对于广泛使用的枚举名称，仍建议遵循上述步骤。
不要更改字段类型 几乎不要更改字段类型；这会导致反序列化出错，与重复使用标签号类似。 protobuf 文档 列举了极少数可以更改的情况（如 int32、uint32、int64 和 bool 之间）。但更改字段的消息类型会导致破坏，除非新消息是旧消息的超集。
不要添加必填字段 绝不要添加必填字段，建议用 // required 注释来说明 API 合约。必填字段被认为有害，已在 proto3 中完全移除。所有字段应为 optional 或 repeated。你无法预知消息类型会存在多久，也无法预知四年后某人是否被迫用空字符串或零来填充你定义的必填字段。
对于 proto3，没有 required 字段，因此此建议不适用。
不要创建包含大量字段的消息 不要创建包含“很多”（比如上百个）字段的消息。在 C++ 中，每个字段无论是否被赋值，都会增加大约 65 位的内存占用（8 字节指针，如果声明为 optional，还会有一个位用于标记是否被赋值）。当 proto 过大时，生成的代码甚至可能无法编译（例如 Java 对方法大小有限制）。
要在枚举中包含未指定值 枚举应在声明的第一个值中包含默认的 FOO_UNSPECIFIED。当 proto2 枚举添加新值时，旧客户端会将该字段视为未设置，getter 会返回默认值或第一个声明的值（如果没有默认值）。为保证与 proto 枚举 的一致性，第一个声明的枚举值应为默认的 FOO_UNSPECIFIED，且编号为 0。不要将默认值声明为有实际意义的值，这有助于协议随时间演进。所有声明在同一消息下的枚举值在 C++ 命名空间中相同，因此应使用枚举名作为前缀，避免编译错误。如果不需要跨语言常量，int32 能保留未知值且生成的代码更少。注意 proto 枚举 要求第一个值为 0，并且可以对未知枚举值进行序列化和反序列化。</description></item><item><title>避免盲目跟风</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/no-cargo-cults/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/no-cargo-cults/</guid><description>不要在 proto 文件中进行 盲目跟风 设置。如果你是基于现有的 schema 定义创建新的 proto 文件，除非你理解某个 option 设置的必要性，否则不要随意应用。
针对 Editions 的最佳实践 除非确有必要，避免在 .proto 文件中应用 editions 功能。 这些功能通常表示使用了实验性的未来行为或已弃用的过去行为。最新 edition 的最佳实践始终为默认。新的 proto schema 定义内容应保持无功能设置，除非你希望提前采用某个即将推出的功能。
在不了解设置原因的情况下复制功能设置，可能会导致代码出现意外行为。</description></item><item><title>API 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/api/</guid><description>已针对 proto3 更新。欢迎补丁！
本文档是 Proto 最佳实践 的补充。 它不是针对 Java/C++/Go 及其他 API 的规定。
如果你在代码评审中发现 proto 偏离了这些指南，请将作者指向本主题，帮助传播最佳实践。
注意 这些指南仅供参考，且许多有明确的例外。例如，如果你在编写性能关键的后端，可能会为了速度牺牲灵活性或安全性。本主题将帮助你更好地理解权衡，并做出适合你场景的决策。 精确、简明地为大多数字段和消息编写文档 你的 proto 很可能会被不了解你设计初衷的人继承和使用。请用对新团队成员或客户有用的术语为每个字段编写文档。
具体示例：
// 错误：启用 Foo 的选项 // 正确：控制 Foo 功能行为的配置。 message FeatureFooConfig { // 错误：设置是否启用该功能 // 正确：必填字段，指示是否为 account_id 启用 Foo 功能。 // 如果 account_id 的 FOO_OPTIN Gaia 位未设置，必须为 false。 optional bool enabled; } // 错误：Foo 对象。 // 正确：API 中面向客户端的 Foo（what/foo）表示。 message Foo { // 错误：foo 的标题。 // 正确：表示用户提供的 Foo 标题，无归一化或转义。 // 示例标题：&amp;#34;Picture of my cat in a box &amp;lt;3 &amp;lt;3 !</description></item><item><title>1-1-1 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/1-1-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/1-1-1/</guid><description>1-1-1 最佳实践是尽可能将每个 proto_library 和 .proto 文件保持小巧，理想情况是：
一个 proto_library 构建规则 一个源 .proto 文件 一个顶级实体（消息、枚举或扩展） 尽可能减少消息、枚举、扩展和服务的数量可以使重构更容易。当文件分离时，移动文件比从包含其他消息的文件中提取消息更容易。
遵循此实践可以通过减少实际中传递依赖项的大小来帮助构建时间和二进制文件大小：当某些代码只需要使用一个枚举时，在 1-1-1 设计下，它可以仅依赖定义该枚举的 .proto 文件，而避免意外地引入可能仅被同一文件中定义的其他消息使用的大量传递依赖项。
在某些情况下，1-1-1 理想情况可能不可行（循环依赖）、不理想（极其概念上耦合的消息放在一起有助于可读性），或者某些缺点不适用（当 .proto 文件没有导入时，就没有关于传递依赖项大小的技术问题）。与任何最佳实践一样，请根据实际情况判断何时偏离该指南。
在创建 gRPC 定义时，proto 模式文件的模块化非常重要。以下是一组展示模块化结构的 proto 文件。
student_id.proto
edition = &amp;#34;2023&amp;#34;; package my.package; message StudentId { string value = 1; } full_name.proto
edition = &amp;#34;2023&amp;#34;; package my.package; message FullName { string family_name = 1; string given_name = 2; } student.proto
edition = &amp;#34;2023&amp;#34;; package my.package; import &amp;#34;student_id.proto&amp;#34;; import &amp;#34;full_name.</description></item></channel></rss>