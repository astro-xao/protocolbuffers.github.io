<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程指南 on Protocol Buffers Documentation</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/</link><description>Recent content in 编程指南 on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Language Guide (editions)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Language Guide (proto 2)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Language Guide (proto 3)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on the proto2 syntax, see the Proto2 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>Proto Limits</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</guid><description>This topic documents the limits to the number of supported elements (fields, enum values, and so on) in proto schemas.
This information is a collection of discovered limitations by many engineers, but is not exhaustive and may be incorrect/outdated in some areas. As you discover limitations in your work, contribute those to this document to help others.
Number of Fields Message with only singular proto fields (such as Boolean):
~2100 fields (proto2) ~3100 (proto3 without using optional fields) Empty message extended by singular fields (such as Boolean):</description></item><item><title>Style Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</guid><description>This document provides a style guide for .proto files. By following these conventions, you&amp;rsquo;ll make your protocol buffer message definitions and their corresponding classes consistent and easy to read.
Standard File Formatting Keep the line length to 80 characters. Use an indent of 2 spaces. Prefer the use of double quotes for strings. File Structure Files should be named lower_snake_case.proto.
All files should be ordered in the following manner:
License header (if applicable) File overview Syntax Package Imports (sorted) File options Everything else Identifier naming styles Protobuf identifiers use one of the following naming styles:</description></item><item><title>Enum Behavior</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</guid><description>Enums behave differently in different language libraries. This topic covers the different behaviors as well as the plans to move protobufs to a state where they are consistent across all languages. If you&amp;rsquo;re looking for information on how to use enums in general, see the corresponding sections in the proto2 and proto3 language guide topics.
Definitions Enums have two distinct flavors (open and closed). They behave identically except in their handling of unknown values.</description></item><item><title>Encoding</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON Format</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</guid><description>Protobuf supports a canonical encoding in JSON, making it easier to share data with systems that do not support the standard protobuf binary wire format.
ProtoJSON Format is not as efficient as protobuf wire format. The converter uses more CPU to encode and decode messages and (except in rare cases) encoded messages consume more space. Furthermore, ProtoJSON format puts your field and enum value names into encoded messages making it much harder to change those names later.</description></item><item><title>Techniques</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</guid><description>You can also send design and usage questions to the Protocol Buffers discussion group.
Common Filename Suffixes It is fairly common to write messages to files in several different formats. We recommend using the following file extensions for these files.
Content Extension Text Format .txtpb Wire Format .binpb JSON Format .json For Text Format specifically, .textproto is also fairly common, but we recommend .txtpb for its brevity.
Streaming Multiple Messages If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins.</description></item><item><title>第三方插件</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</guid><description>许多开源项目致力于为 Protocol Buffers 增加有用的功能。要查看我们已知项目的链接列表，请参阅 第三方插件 Wiki 页面。</description></item><item><title>Extension Declarations</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</guid><description>Introduction This page describes in detail what extension declarations are, why we need them, and how we use them.
Note Proto3 does not support extensions (except for declaring custom options). Extensions are fully supported in proto2 and editions though. If you need an introduction to extensions, read this extensions guide
Motivation Extension declarations aim to strike a happy medium between regular fields and extensions. Like extensions, they avoid creating a dependency on the message type of the field, which therefore results in a leaner build graph and smaller binaries in environments where unused messages are difficult or impossible to strip.</description></item><item><title>Application Note: Field Presence</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Note We recommend always adding the optional label for proto3 basic types. This provides a smoother path to editions, which uses explicit presence by default.</description></item><item><title>Proto Serialization Is Not Canonical</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</guid><description>Many people want a serialized proto to canonically represent the contents of that proto. Use cases include:
using a serialized proto as a key in a hash table taking a fingerprint or checksum of a serialized proto comparing serialized payloads as a way of checking message equality Unfortunately, protobuf serialization is not (and cannot be) canonical. There are a few notable exceptions, such as MapReduce, but in general you should generally think of proto serialization as unstable.</description></item><item><title>反序列化 Debug Proto 表示</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</guid><description>从 30.x 版本开始，Protobuf 的 DebugString API（如 Message::DebugString、Message::ShortDebugString、Message::Utf8DebugString）、其他 Protobuf API（如 proto2::ShortFormat、proto2::Utf8Format）、Abseil 字符串函数（如 absl::StrCat、absl::StrFormat、absl::StrAppend 和 absl::Substitute），以及 Abseil 日志 API，将会自动把 proto 参数转换为新的调试格式。相关公告请参见这里。
与 Protobuf DebugString 输出格式不同，新的调试格式会自动将敏感字段的值替换为字符串 &amp;ldquo;[REDACTED]&amp;quot;（不带引号）。此外，为确保这种新的输出格式无法被 Protobuf TextFormat 解析器反序列化（无论底层 proto 是否包含 SPII 字段），我们会添加一组随机链接指向本文，并插入随机长度的空白序列。新的调试格式如下所示：
goo.gle/debugstr spii_field: [REDACTED] normal_field: &amp;#34;value&amp;#34; 请注意，新的调试格式与 DebugString 格式的输出仅有以下两点不同：
URL 前缀 SPII 字段的值被替换为 &amp;ldquo;[REDACTED]&amp;quot;（不带引号） 新的调试格式绝不会移除任何字段名；它只会在字段被认为是敏感时将其值替换为 &amp;ldquo;[REDACTED]&amp;quot;。 如果你在输出中没有看到某些字段，那是因为这些字段在 proto 中未被设置。
提示： 如果你只看到 URL 而没有其他内容，说明你的 proto 是空的！
为什么会有这个 URL？ 我们希望确保没有人将面向人类的 protobuf 消息可读表示反序列化。历史上，.DebugString() 和 TextFormat 是可以互换的，现有系统也常用 DebugString 来传输和存储数据。
我们希望敏感数据不会意外出现在日志中。因此，在将 protobuf 消息转换为字符串（&amp;quot;[REDACTED]&amp;quot;）之前，我们会自动对某些字段值进行脱敏。这降低了意外日志记录带来的安全和隐私风险，但如果其他系统反序列化你的消息，则可能导致数据丢失。为了解决这个风险，我们有意将机器可读的 TextFormat 与用于日志消息的人类可读调试格式分开。</description></item></channel></rss>