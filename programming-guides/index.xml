<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程指南 on Protocol Buffers 文档</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/</link><description>Recent content in 编程指南 on Protocol Buffers 文档</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/index.xml" rel="self" type="application/rss+xml"/><item><title>语言指南 (proto 2)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>语言指南 (proto 3)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</guid><description>本指南介绍如何使用 protocol buffer 语言来构建你的 protocol buffer 数据，包括 .proto 文件的语法以及如何根据 .proto 文件生成数据访问类。内容涵盖了 protocol buffer 语言的 proto3 版本。
有关editions语法的信息，请参见 Protobuf Editions Language Guide。
有关proto2语法的信息，请参见 Proto2 Language Guide。
这是一个参考指南——如果你需要一个包含本文件中许多特性的分步示例，请参见你所选语言的 教程。
定义消息类型 首先让我们来看一个非常简单的例子。假设你想定义一个搜索请求消息格式，每个搜索请求包含一个查询字符串、你感兴趣的结果页码，以及每页的结果数。你可以使用如下的 .proto 文件来定义该消息类型。
syntax = &amp;#34;proto3&amp;#34;; message SearchRequest { string query = 1; int32 page_number = 2; int32 results_per_page = 3; } 文件的第一行指定你正在使用 protocol buffer 语言规范的 proto3 版本。
* `edition`（或 proto2/proto3 的 `syntax`）必须是文件的第一行非空、非注释内容。 * 如果没有指定 `edition` 或 `syntax`，protocol buffer 编译器会假定你正在使用 [proto2](./programming-guides/proto2)。 SearchRequest 消息定义了三个字段（名称/值对），每个字段对应你想在该类型消息中包含的一项数据。每个字段都有名称和类型。</description></item><item><title>语言指南(editions)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Proto 限制</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</guid><description>本文档记录了 proto schema 中支持的元素数量（字段、枚举值等）的限制。
这些信息由许多工程师收集整理，但并不详尽，部分内容可能已过时或不准确。欢迎在工作中发现新的限制后，补充到本文档，帮助他人。
字段数量限制 仅包含单一 proto 字段（如 Boolean）的消息：
~2100 个字段（proto2） ~3100 个字段（proto3，未使用 optional 字段） 通过单一字段（如 Boolean）扩展的空消息：
~4100 个字段（proto2） proto3 不支持扩展。
要测试此限制，可创建一个超过上述上限字段数量的 proto 消息，并使用 Java proto 规则进行编译。该限制来源于 JVM 规范。
枚举值数量限制 最低限制约为 1700 个值（Java）。其他语言有不同的限制。
消息总大小限制 任何序列化形式的 proto 消息必须小于 2GiB，这是所有实现支持的最大大小。建议限制请求和响应的大小。
Proto 反序列化深度限制 Java： 100 C++： 100 Go： 10000 （计划将其减少到 100） 如果尝试反序列化嵌套深度超过限制的消息，反序列化将失败。</description></item><item><title>风格指南</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</guid><description>本文档为 .proto 文件提供了风格指南。遵循这些约定，可以让您的协议缓冲区消息定义及其对应的类保持一致且易于阅读。
标准文件格式 保持每行长度不超过 80 个字符。 使用 2 个空格缩进。 字符串建议使用双引号。 文件结构 文件应命名为 lower_snake_case.proto。
所有文件应按以下顺序排列：
许可证头（如适用） 文件概述 语法声明 包声明 导入（排序） 文件选项 其他内容 标识符命名风格 Protobuf 标识符使用以下命名风格之一：
TitleCase 包含大写字母、小写字母和数字 首字母为大写字母 每个单词的首字母大写 lower_snake_case 包含小写字母、下划线和数字 单词之间用单个下划线分隔 UPPER_SNAKE_CASE 包含大写字母、下划线和数字 单词之间用单个下划线分隔 camelCase 包含大写字母、小写字母和数字 首字母为小写字母 每个后续单词的首字母大写 注意： 下述风格指南不建议在 .proto 文件中使用 camelCase，仅为说明某些语言生成的代码可能会将标识符转换为此风格。 所有情况下，缩写应视为单个单词：使用 GetDnsRequest 而不是 GetDNSRequest，使用 dns_request 而不是 d_n_s_request。
标识符中的下划线 不要在名称的开头或结尾使用下划线。任何下划线后面都应跟字母（而不是数字或第二个下划线）。
此规则的动机在于，每种 protobuf 语言实现可能会将标识符转换为本地语言风格：.proto 文件中的 song_id 字段在不同语言中可能分别变为 SongId、songId 或 song_id。
仅在字母前使用下划线，可以避免名称在一种风格下不同，但转换为另一种风格后发生冲突的情况。
例如，DNS2 和 DNS_2 转换为 TitleCase 都会变为 Dns2。允许这两种命名会导致在某些语言中生成的代码保持原有 UPPER_SNAKE_CASE 风格并广泛使用，后来在另一种语言中转换为 TitleCase 时发生冲突。</description></item><item><title>枚举行为</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</guid><description>不同语言库中枚举的行为各不相同。本主题介绍了这些不同的行为，以及将 protobufs 迁移到所有语言一致状态的计划。如果你想了解如何使用枚举，请参阅 proto2 和 proto3 语言指南中的相关章节。
定义 枚举有两种不同的类型（开放 和 封闭）。它们的行为完全相同，除了对未知值的处理方式不同。实际上，这意味着简单场景下行为一致，但某些边界情况会有有趣的影响。
为便于说明，假设我们有如下 .proto 文件（此处有意未指定 syntax = &amp;quot;proto2&amp;quot; 还是 syntax = &amp;quot;proto3&amp;quot;）：
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } 开放 和 封闭 的区别可以用一个问题来概括：
当程序解析包含字段 1 且值为 2 的二进制数据时会发生什么？
开放枚举会解析值 2 并直接存储在字段中。访问器会报告该字段已设置，并返回代表 2 的内容。 封闭枚举会解析值 2 并将其存储在消息的未知字段集中。访问器会报告该字段为未设置，并返回枚举的默认值。 封闭 枚举的影响 封闭 枚举在解析重复字段时会带来意想不到的后果。当解析 repeated Enum 字段时，所有未知值都会被放入 未知字段 集中。序列化时，这些未知值会被再次写出，但不会在原列表中的原始位置。例如，给定如下 .proto 文件：
enum Enum { A = 0; B = 1; } message Msg { repeated Enum r = 1; } 如果线格式包含字段 1 的值为 [0, 2, 1, 2]，则重复字段解析后为 [0, 1]，而 [2, 2] 会被存储为未知字段。重新序列化消息后，线格式将变为 [0, 1, 2, 2]。</description></item><item><title>Encoding</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON 格式</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</guid><description>Protobuf 支持一种规范的 JSON 编码格式，使得与不支持标准 protobuf 二进制格式的系统之间的数据共享更加容易。
ProtoJSON 格式的效率不如 protobuf 二进制格式。转换器在编码和解码消息时会消耗更多的 CPU，并且（除极少数情况外）编码后的消息占用的空间也更大。此外，ProtoJSON 格式会将你的字段名和枚举值名写入编码消息，这会导致后续更改这些名称变得更加困难。移除字段会造成兼容性破坏，并触发解析错误。简而言之，Google 更倾向于在几乎所有场景下使用标准二进制格式而不是 ProtoJSON 格式，是有充分理由的。
各类型的编码方式将在后文的表格中详细说明。
当将 JSON 编码的数据解析为 protocol buffer 时，如果某个值缺失或其值为 null，则会被解释为对应的默认值。对于单个字段的多次赋值（使用重复或等价的 JSON 键），解析时会保留最后一个值，这与二进制格式解析一致。注意，并非所有 protobuf JSON 解析器实现都符合规范，一些不符合规范的实现可能会拒绝重复键。
当从 protocol buffer 生成 JSON 编码输出时，如果 protobuf 字段为默认值且不支持字段存在性（presence），则默认情况下不会在输出中包含该字段。实现可以提供选项，将默认值字段包含在输出中。
已设置值且支持字段存在性的字段，在 JSON 编码输出中总会包含该字段，即使其为默认值。例如，proto3 中用 optional 关键字定义的字段支持存在性，如果被设置，则总会出现在 JSON 输出中。任何版本的 protobuf 中的消息类型字段都支持存在性，如果被设置也会出现在输出中。proto3 中隐式存在性的标量字段，只有在其值不是该类型的默认值时才会出现在 JSON 输出中。
在 JSON 文件中表示数值数据时，如果从二进制格式解析出的数字不适合对应的类型，将会像在 C++ 中强制类型转换一样（例如，将 64 位数字读取为 int32 时会被截断为 32 位）。
下表展示了各类数据在 JSON 文件中的表示方式。
Protobuf JSON JSON 示例 说明 message object {"</description></item><item><title>技术技巧</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</guid><description>你也可以将设计和使用相关的问题发送到 Protocol Buffers 讨论组。
常见文件名后缀 通常会以多种不同格式将消息写入文件。我们建议为这些文件使用以下扩展名。
内容 扩展名 文本格式 .txtpb 二进制格式 .binpb JSON 格式 .json 对于文本格式，.textproto 也很常见，但我们推荐使用 .txtpb，因为它更简洁。
多消息流式处理 如果你想将多个消息写入同一个文件或流，需要自己跟踪每个消息的起止位置。Protocol Buffer 的二进制格式不是自描述的，因此解析器无法自行判断消息的结束位置。最简单的解决方法是，在写入每个消息前先写入其大小。读取时，先读取大小，再将对应字节读入缓冲区，然后解析该缓冲区。（如果想避免复制字节到单独缓冲区，可以查看 CodedInputStream 类（C++ 和 Java 均有），它可以限制读取的字节数。）
大数据集 Protocol Buffers 并不适合处理大型消息。一般来说，如果每条消息超过 1MB，建议考虑其他方案。
不过，Protocol Buffers 非常适合处理大型数据集中的单条消息。通常，大型数据集由许多结构化的小数据组成。虽然 Protocol Buffers 无法一次处理整个数据集，但用它编码每个小数据块可以大大简化问题：你只需处理一组字节串，而不是一组结构体。
Protocol Buffers 没有内置对大数据集的支持，因为不同场景需要不同的解决方案。有时只需简单的记录列表，有时则需要类似数据库的结构。每种方案都应作为独立库开发，只有需要的人才需承担相应的成本。
自描述消息 Protocol Buffers 本身不包含类型描述。因此，仅凭原始消息而没有对应的 .proto 文件，很难提取有用数据。
不过，.proto 文件的内容本身可以用 Protocol Buffers 表示。源码包中的 src/google/protobuf/descriptor.proto 定义了相关消息类型。protoc 可以通过 --descriptor_set_out 选项输出 FileDescriptorSet，它表示一组 .proto 文件。你可以这样定义自描述协议消息：
syntax = &amp;#34;proto3&amp;#34;; import &amp;#34;google/protobuf/any.proto&amp;#34;; import &amp;#34;google/protobuf/descriptor.proto&amp;#34;; message SelfDescribingMessage { // 描述类型及其依赖的 FileDescriptorProto 集合。 google.</description></item><item><title>第三方插件</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</guid><description>许多开源项目致力于为 Protocol Buffers 增加有用的功能。要查看我们已知项目的链接列表，请参阅 第三方插件 Wiki 页面。</description></item><item><title>扩展声明</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</guid><description>简介 本页详细介绍了扩展声明是什么、为什么需要它们以及如何使用它们。
注意 Proto3 不支持扩展（除了声明自定义选项）。 扩展在 proto2 和 editions 中完全支持。 如果你需要扩展的入门介绍，请阅读此扩展指南
动机 扩展声明旨在在常规字段和扩展之间取得平衡。像扩展一样，它们避免了对字段消息类型的依赖，从而在难以或无法剥离未使用消息的环境中实现更精简的构建图和更小的二进制文件。像常规字段一样，字段名称/编号会出现在封闭消息中，这使得避免冲突和方便查看已声明字段列表变得更容易。
通过扩展声明列出已占用的扩展编号，使用户更容易选择可用的扩展编号并避免冲突。
用法 扩展声明是扩展范围的一种选项。类似于 C++ 的前向声明，你可以声明扩展字段的类型、字段名和基数（单个或重复），而无需导入包含完整扩展定义的 .proto 文件：
edition = &amp;#34;2023&amp;#34;; message Foo { extensions 4 to 1000 [ declaration = { number: 4, full_name: &amp;#34;.my.package.event_annotations&amp;#34;, type: &amp;#34;.logs.proto.ValidationAnnotations&amp;#34;, repeated: true }, declaration = { number: 999, full_name: &amp;#34;.foo.package.bar&amp;#34;, type: &amp;#34;int32&amp;#34;}]; } 该语法具有以下语义：
如果范围足够大，可以在单个扩展范围内定义多个具有不同扩展编号的 declaration。 如果扩展范围有任何声明，则该范围的所有扩展也必须声明。这可以防止添加未声明的扩展，并强制任何新扩展都使用声明。 给定的消息类型（如 .logs.proto.ValidationAnnotations）不需要事先定义或导入。只需检查它是否是一个有效的名称，可能在其他 .proto 文件中定义。 当此或其他 .proto 文件为该消息（Foo）定义扩展且名称或编号匹配时，将强制扩展的编号、类型和全名与此处的前向声明一致。 警告 避免对扩展范围组（如 extensions 4, 999）使用声明。目前尚不清楚声明适用于哪个扩展范围，并且目前不支持。 扩展声明期望有两个不同包的扩展字段：</description></item><item><title>Application Note: Field Presence</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Note We recommend always adding the optional label for proto3 basic types. This provides a smoother path to editions, which uses explicit presence by default.</description></item><item><title>Proto 序列化不是规范化的</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</guid><description>许多人希望序列化后的 proto 能规范地代表其内容。常见用例包括：
将序列化的 proto 用作哈希表的键 对序列化的 proto 取指纹或校验和 通过比较序列化后的数据判断消息是否相等 不幸的是，protobuf 的序列化不是（也无法做到）规范化。虽然有一些特殊情况（如 MapReduce），但通常你应该认为 proto 的序列化结果是不稳定的。本文将解释原因。
确定性并不等于规范化 确定性序列化并不等于规范化。序列化器可能因多种原因生成不同的输出，包括但不限于以下变化：
protobuf 的 schema 发生任何变化。 构建的应用发生任何变化。 二进制文件使用不同的编译参数（如 opt 与 debug）。 protobuf 库被更新。 这意味着序列化 proto 的哈希值是脆弱的，无法在不同时间或空间保持稳定。
导致序列化输出变化的原因有很多，上述列表并不详尽。其中有些是该问题领域内固有的困难，即使我们想要，也难以保证规范化序列化。还有一些是我们有意未定义的，以便为优化留出空间。
稳定序列化的固有障碍 Protobuf 对象会保留未知字段，以实现前向和后向兼容性。未知字段无法规范化序列化：
未知字段无法区分字节和子消息，因为它们的 wire type 相同。这导致无法对存储在未知字段集中的消息进行规范化。如果要规范化，我们需要递归进入未知子消息并按字段号排序，但我们没有足够的信息来做到这一点。 未知字段总是在已知字段之后序列化，以提高效率。但规范化序列化要求按字段号将未知字段与已知字段交错序列化。这会给所有人带来效率和代码体积的开销，即使他们并未使用该特性。 有意未定义的内容 即使规范化序列化是可行的（即我们能解决未知字段问题），我们也会有意将序列化顺序未定义，以便获得更多优化空间：
如果我们能证明某个字段在二进制中从未被使用，可以将其从 schema 中完全移除，并作为未知字段处理。这能显著节省代码体积和 CPU 周期。 有时可以通过将同一字段的向量一起序列化来优化，尽管这会打破字段号顺序。 为了给这些优化留出空间，我们希望在某些配置下有意打乱字段顺序，防止应用错误地依赖字段顺序。</description></item><item><title>反序列化 Debug Proto 表示</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</guid><description>从 30.x 版本开始，Protobuf 的 DebugString API（如 Message::DebugString、Message::ShortDebugString、Message::Utf8DebugString）、其他 Protobuf API（如 proto2::ShortFormat、proto2::Utf8Format）、Abseil 字符串函数（如 absl::StrCat、absl::StrFormat、absl::StrAppend 和 absl::Substitute），以及 Abseil 日志 API，将会自动把 proto 参数转换为新的调试格式。相关公告请参见这里。
与 Protobuf DebugString 输出格式不同，新的调试格式会自动将敏感字段的值替换为字符串 &amp;ldquo;[REDACTED]&amp;quot;（不带引号）。此外，为确保这种新的输出格式无法被 Protobuf TextFormat 解析器反序列化（无论底层 proto 是否包含 SPII 字段），我们会添加一组随机链接指向本文，并插入随机长度的空白序列。新的调试格式如下所示：
goo.gle/debugstr spii_field: [REDACTED] normal_field: &amp;#34;value&amp;#34; 请注意，新的调试格式与 DebugString 格式的输出仅有以下两点不同：
URL 前缀 SPII 字段的值被替换为 &amp;ldquo;[REDACTED]&amp;quot;（不带引号） 新的调试格式绝不会移除任何字段名；它只会在字段被认为是敏感时将其值替换为 &amp;ldquo;[REDACTED]&amp;quot;。 如果你在输出中没有看到某些字段，那是因为这些字段在 proto 中未被设置。
提示： 如果你只看到 URL 而没有其他内容，说明你的 proto 是空的！
为什么会有这个 URL？ 我们希望确保没有人将面向人类的 protobuf 消息可读表示反序列化。历史上，.DebugString() 和 TextFormat 是可以互换的，现有系统也常用 DebugString 来传输和存储数据。
我们希望敏感数据不会意外出现在日志中。因此，在将 protobuf 消息转换为字符串（&amp;quot;[REDACTED]&amp;quot;）之前，我们会自动对某些字段值进行脱敏。这降低了意外日志记录带来的安全和隐私风险，但如果其他系统反序列化你的消息，则可能导致数据丢失。为了解决这个风险，我们有意将机器可读的 TextFormat 与用于日志消息的人类可读调试格式分开。</description></item></channel></rss>