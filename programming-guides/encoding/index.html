<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/protocolbuffers.github.io/favicons/favicon.ico><link rel=apple-touch-icon href=/protocolbuffers.github.io/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/protocolbuffers.github.io/favicons/android-192x192.png sizes=192x192><title>编码 | Protocol Buffers 文档 (由 GPT-4.1 翻译)</title>
<meta name=description content="解释 Protocol Buffers 如何将数据编码到文件或传输到网络。"><meta property="og:title" content="编码"><meta property="og:description" content="解释 Protocol Buffers 如何将数据编码到文件或传输到网络。"><meta property="og:type" content="article"><meta property="og:url" content="https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/"><meta property="article:section" content="programming-guides"><meta itemprop=name content="编码"><meta itemprop=description content="解释 Protocol Buffers 如何将数据编码到文件或传输到网络。"><meta itemprop=wordCount content="1047"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="编码"><meta name=twitter:description content="解释 Protocol Buffers 如何将数据编码到文件或传输到网络。"><link rel=preload href=/protocolbuffers.github.io/scss/main.min.27bc098c9a8f7a1246d474f5c8afcee53760c9c7f38125d343ff52e0bf493011.css as=style integrity="sha256-J7wJjJqPehJG1HT1yK/O5TdgycfzgSXTQ/9S4L9JMBE=" crossorigin=anonymous><link href=/protocolbuffers.github.io/scss/main.min.27bc098c9a8f7a1246d474f5c8afcee53760c9c7f38125d343ff52e0bf493011.css rel=stylesheet integrity="sha256-J7wJjJqPehJG1HT1yK/O5TdgycfzgSXTQ/9S4L9JMBE=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/protocolbuffers.github.io/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers 文档 (由 GPT-4.1 翻译)</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav></ul></div><div class="d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><div id=content-mobile><form class="td-sidebar__search d-flex align-items-center"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form></div><div id=content-desktop></div><nav class="td-sidebar-nav collapse td-sidebar-nav--search-disabled" id=td-section-nav><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-protocolbuffersgithubio-li><a href=/protocolbuffers.github.io/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-protocolbuffersgithubio><span>Protocol Buffer</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiooverview-li><a href=/protocolbuffers.github.io/overview/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiooverview><span>概述</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioinstallation-li><a href=/protocolbuffers.github.io/installation/ title="Protocol Buffer 编译器安装" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioinstallation><span>Protoc 安装</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubionews-li><a href=/protocolbuffers.github.io/news/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubionews><span>News</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-protocolbuffersgithubioprogramming-guides-li><a href=/protocolbuffers.github.io/programming-guides/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioprogramming-guides><span>编程指南</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesproto2-li><a href=/protocolbuffers.github.io/programming-guides/proto2/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesproto2><span>语言指南 (proto 2)</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesproto3-li><a href=/protocolbuffers.github.io/programming-guides/proto3/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesproto3><span>语言指南 (proto 3)</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guideseditions-li><a href=/protocolbuffers.github.io/programming-guides/editions/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guideseditions><span>语言指南(editions)</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesproto-limits-li><a href=/protocolbuffers.github.io/programming-guides/proto-limits/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesproto-limits><span>Proto 限制</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesstyle-li><a href=/protocolbuffers.github.io/programming-guides/style/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesstyle><span>风格指南</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesenum-li><a href=/protocolbuffers.github.io/programming-guides/enum/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesenum><span>枚举行为</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-protocolbuffersgithubioprogramming-guidesencoding-li><a href=/protocolbuffers.github.io/programming-guides/encoding/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesencoding><span class=td-sidebar-nav-active-item>编码</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesjson-li><a href=/protocolbuffers.github.io/programming-guides/json/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesjson><span>ProtoJSON 格式</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidestechniques-li><a href=/protocolbuffers.github.io/programming-guides/techniques/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidestechniques><span>技术技巧</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesaddons-li><a href=/protocolbuffers.github.io/programming-guides/addons/ title=第三方插件 class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesaddons><span>插件</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesextension_declarations-li><a href=/protocolbuffers.github.io/programming-guides/extension_declarations/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesextension_declarations><span>扩展声明</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesfield_presence-li><a href=/protocolbuffers.github.io/programming-guides/field_presence/ title="Application Note: Field Presence" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesfield_presence><span>Field Presence</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesserialization-not-canonical-li><a href=/protocolbuffers.github.io/programming-guides/serialization-not-canonical/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesserialization-not-canonical><span>Proto 序列化不是规范化的</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioprogramming-guidesdeserialize-debug-li><a href=/protocolbuffers.github.io/programming-guides/deserialize-debug/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioprogramming-guidesdeserialize-debug><span>反序列化 Debug Proto 表示</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioeditions-li><a href=/protocolbuffers.github.io/editions/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioeditions><span>Protobuf 版本</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioeditionsoverview-li><a href=/protocolbuffers.github.io/editions/overview/ title="Protobuf Editions Overview" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioeditionsoverview><span>Overview</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioeditionsfeatures-li><a href=/protocolbuffers.github.io/editions/features/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioeditionsfeatures><span>Feature Settings for Editions</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioeditionsimplementation-li><a href=/protocolbuffers.github.io/editions/implementation/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioeditionsimplementation><span>Implementing Editions Support</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubiodesign-decisions-li><a href=/protocolbuffers.github.io/design-decisions/ title="Protobuf 团队设计决策" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubiodesign-decisions><span>设计决策</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiodesign-decisionsnullable-getters-setters-li><a href=/protocolbuffers.github.io/design-decisions/nullable-getters-setters/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiodesign-decisionsnullable-getters-setters><span>不支持可空 Setter/Getters</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubiobest-practices-li><a href=/protocolbuffers.github.io/best-practices/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubiobest-practices><span>Proto 最佳实践</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiobest-practicesdos-donts-li><a href=/protocolbuffers.github.io/best-practices/dos-donts/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiobest-practicesdos-donts><span>Proto 最佳实践</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiobest-practicesno-cargo-cults-li><a href=/protocolbuffers.github.io/best-practices/no-cargo-cults/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiobest-practicesno-cargo-cults><span>避免盲目跟风</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiobest-practicesapi-li><a href=/protocolbuffers.github.io/best-practices/api/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiobest-practicesapi><span>API 最佳实践</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiobest-practices1-1-1-li><a href=/protocolbuffers.github.io/best-practices/1-1-1/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiobest-practices1-1-1><span>1-1-1 最佳实践</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubiogetting-started-li><a href=/protocolbuffers.github.io/getting-started/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubiogetting-started><span>教程</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedcpptutorial-li><a href=/protocolbuffers.github.io/getting-started/cpptutorial/ title="Protocol Buffer Basics: C++" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedcpptutorial><span>C++</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedcsharptutorial-li><a href=/protocolbuffers.github.io/getting-started/csharptutorial/ title="Protocol Buffer Basics: C#" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedcsharptutorial><span>C#</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-starteddarttutorial-li><a href=/protocolbuffers.github.io/getting-started/darttutorial/ title="Protocol Buffer Basics: Dart" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-starteddarttutorial><span>Dart</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedgotutorial-li><a href=/protocolbuffers.github.io/getting-started/gotutorial/ title="Protocol Buffer Basics: Go" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedgotutorial><span>Go</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedjavatutorial-li><a href=/protocolbuffers.github.io/getting-started/javatutorial/ title="Protocol Buffer Basics: Java" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedjavatutorial><span>Java</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedkotlintutorial-li><a href=/protocolbuffers.github.io/getting-started/kotlintutorial/ title="Protocol Buffer Basics: Kotlin" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedkotlintutorial><span>Kotlin</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiogetting-startedpythontutorial-li><a href=/protocolbuffers.github.io/getting-started/pythontutorial/ title="Protocol Buffer Basics: Python" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiogetting-startedpythontutorial><span>Python</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreference-li><a href=/protocolbuffers.github.io/reference/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreference><span>参考指南</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencecpp-li><a href=/protocolbuffers.github.io/reference/cpp/ title="C++ Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencecpp><span>C++</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecppcpp-generated-li><a href=/protocolbuffers.github.io/reference/cpp/cpp-generated/ title="C++ Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecppcpp-generated><span>Generated Code Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecppstring-view-li><a href=/protocolbuffers.github.io/reference/cpp/string-view/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecppstring-view><span>String View APIs</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecpparenas-li><a href=/protocolbuffers.github.io/reference/cpp/arenas/ title="C++ Arena Allocation Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecpparenas><span>Arena Allocation Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecppabseil-li><a href=/protocolbuffers.github.io/reference/cpp/abseil/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecppabseil><span>Abseil Support</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecppapi-docs-link-li><a href=/reference/cpp/api-docs/ target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecppapi-docs-link><span>C++ API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencecsharp-li><a href=/protocolbuffers.github.io/reference/csharp/ title="C# Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencecsharp><span>C#</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecsharpcsharp-generated-li><a href=/protocolbuffers.github.io/reference/csharp/csharp-generated/ title="C# Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecsharpcsharp-generated><span>Generated Code Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencecsharpapi-docs-link-li><a href=/reference/csharp/api-docs target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencecsharpapi-docs-link><span>C# API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencedart-li><a href=/protocolbuffers.github.io/reference/dart/ title="Dart Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencedart><span>Dart</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencedartdart-generated-li><a href=/protocolbuffers.github.io/reference/dart/dart-generated/ title="Dart Generated Code" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencedartdart-generated><span>Generated Code</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencedartapi-docs-link-li><a href=https://pub.dartlang.org/documentation/protobuf target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencedartapi-docs-link><span>Dart API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencego-li><a href=/protocolbuffers.github.io/reference/go/ title="Go 参考" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencego><span>Go</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegogo-generated-li><a href=/protocolbuffers.github.io/reference/go/go-generated/ title="Go 生成代码指南（Open）" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegogo-generated><span>生成代码指南（Open）</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegogo-generated-opaque-li><a href=/protocolbuffers.github.io/reference/go/go-generated-opaque/ title="Go 生成代码指南（Opaque）" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegogo-generated-opaque><span>生成代码指南（Opaque）</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegofaq-li><a href=/protocolbuffers.github.io/reference/go/faq/ title="Go 常见问题" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegofaq><span>常见问题</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegosize-li><a href=/protocolbuffers.github.io/reference/go/size/ title="Go Size 语义" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegosize><span>Size 语义</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegoapi-docs-link-li><a href=https://pkg.go.dev/google.golang.org/protobuf/proto target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegoapi-docs-link><span>Go API</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegoopaque-migration-li><a href=/protocolbuffers.github.io/reference/go/opaque-migration/ title="Go Opaque API 迁移" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegoopaque-migration><span>Opaque API 迁移</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegoopaque-migration-manual-li><a href=/protocolbuffers.github.io/reference/go/opaque-migration-manual/ title="Go Opaque API：手动迁移" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegoopaque-migration-manual><span>Opaque API：手动迁移</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencegoopaque-faq-li><a href=/protocolbuffers.github.io/reference/go/opaque-faq/ title="Go Opaque API 常见问题解答" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencegoopaque-faq><span>Opaque API 常见问题解答</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencejava-li><a href=/protocolbuffers.github.io/reference/java/ title="Java Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencejava><span>Java</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencejavajava-generated-li><a href=/protocolbuffers.github.io/reference/java/java-generated/ title="Java Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencejavajava-generated><span>Generated Code Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencejavajava-proto-names-li><a href=/protocolbuffers.github.io/reference/java/java-proto-names/ title="Java Proto Names" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencejavajava-proto-names><span>Generated Proto Names</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencejavaapi-docs-link-li><a href=/reference/java/api-docs/overview-summary.html target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencejavaapi-docs-link><span>Java API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencekotlin-li><a href=/protocolbuffers.github.io/reference/kotlin/ title="Kotlin Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencekotlin><span>Kotlin</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencekotlinapi-docs-li><a href=/protocolbuffers.github.io/reference/kotlin/api-docs/ title="Kotlin Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencekotlinapi-docs><span>Kotlin</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencekotlinkotlin-generated-li><a href=/protocolbuffers.github.io/reference/kotlin/kotlin-generated/ title="Kotlin Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencekotlinkotlin-generated><span>Generated Code Guide</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferenceobjective-c-li><a href=/protocolbuffers.github.io/reference/objective-c/ title="Objective-C Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferenceobjective-c><span>Objective-C</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceobjective-cobjective-c-generated-li><a href=/protocolbuffers.github.io/reference/objective-c/objective-c-generated/ title="Objective-C Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceobjective-cobjective-c-generated><span>Generated Code Guide</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencephp-li><a href=/protocolbuffers.github.io/reference/php/ title="PHP Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencephp><span>PHP</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencephpphp-generated-li><a href=/protocolbuffers.github.io/reference/php/php-generated/ title="PHP Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencephpphp-generated><span>Generated Code Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencephpapi-docs-link-li><a href=/reference/php/api-docs/ target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencephpapi-docs-link><span>PHP API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferencepython-li><a href=/protocolbuffers.github.io/reference/python/ title="Python Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferencepython><span>Python</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencepythonpython-generated-li><a href=/protocolbuffers.github.io/reference/python/python-generated/ title="Python Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencepythonpython-generated><span>Generated Code Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencepythonapi-docs-link-li><a href=https://googleapis.dev/python/protobuf/latest/ target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencepythonapi-docs-link><span>Python API</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferenceruby-li><a href=/protocolbuffers.github.io/reference/ruby/ title="Ruby Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferenceruby><span>Ruby</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferencerubyruby-generated-li><a href=/protocolbuffers.github.io/reference/ruby/ruby-generated/ title="Ruby Generated Code Guide" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferencerubyruby-generated><span>Generated Code Guide</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubioreferenceprotobuf-li><a href=/protocolbuffers.github.io/reference/protobuf/ title="Protocol Buffers Reference" class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubioreferenceprotobuf><span>Protocol Buffers</span></a><ul class="ul-3 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceprotobufedition-2023-spec-li><a href=/protocolbuffers.github.io/reference/protobuf/edition-2023-spec/ title="Protocol Buffers Edition 2023 Language Specification" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceprotobufedition-2023-spec><span>2023 Language Specification</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceprotobufproto2-spec-li><a href=/protocolbuffers.github.io/reference/protobuf/proto2-spec/ title="Protocol Buffers Version 2 Language Specification" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceprotobufproto2-spec><span>Version 2 Language Specification</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceprotobufproto3-spec-li><a href=/protocolbuffers.github.io/reference/protobuf/proto3-spec/ title="Protocol Buffers Version 3 Language Specification" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceprotobufproto3-spec><span>Version 3 Language Specification</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceprotobuftextformat-spec-li><a href=/protocolbuffers.github.io/reference/protobuf/textformat-spec/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceprotobuftextformat-spec><span>Text Format Language Specification</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceprotobufgoogleprotobuf-li><a href=/protocolbuffers.github.io/reference/protobuf/google.protobuf/ title="Protocol Buffers Well-Known Types" class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceprotobufgoogleprotobuf><span>Well-Known Types</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioreferenceother-li><a href=/protocolbuffers.github.io/reference/other/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioreferenceother><span>其他语言</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child" id=m-protocolbuffersgithubiosupport-li><a href=/protocolbuffers.github.io/support/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section" id=m-protocolbuffersgithubiosupport><span>Support</span></a><ul class="ul-2 foldable"><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiosupportversion-support-li><a href=/protocolbuffers.github.io/support/version-support/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiosupportversion-support><span>Version Support</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiosupportmigration-li><a href=/protocolbuffers.github.io/support/migration/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiosupportmigration><span>Migration Guide</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiosupportcross-version-runtime-guarantee-li><a href=/protocolbuffers.github.io/support/cross-version-runtime-guarantee/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiosupportcross-version-runtime-guarantee><span>Cross-Version Runtime Guarantee</span></a></li></ul></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiodownloads-li><a href=/protocolbuffers.github.io/downloads/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiodownloads><span>Downloads</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiohistory-li><a href=/protocolbuffers.github.io/history/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiohistory><span>History</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubioforum-link-li><a href=https://groups.google.com/g/protobuf target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubioforum-link><span>Forum</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubionavbar-li><a href=/protocolbuffers.github.io/navbar/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubionavbar><span></span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-protocolbuffersgithubiosearch-li><a href=/protocolbuffers.github.io/search/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-protocolbuffersgithubiosearch><span>Search Results</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ml-2 pb-1 pt-2 mb-0"><a href=https://github.com/astro-xao/protocolbuffers.github.io//tree/main/content/programming-guides/encoding.md class=td-page-meta--view target=_blank rel=noopener><i class="fa-solid fa-file-lines fa-fw"></i> View page source</a>
<a href=https://github.com/astro-xao/protocolbuffers.github.io//edit/main/content/programming-guides/encoding.md class=td-page-meta--edit target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> Edit this page</a>
<a href="https://github.com/astro-xao/protocolbuffers.github.io//new/main/content/programming-guides/encoding.md?filename=change-me.md&amp;value=---%0Atitle%3A+%22Long+Page+Title%22%0AlinkTitle%3A+%22Short+Nav+Title%22%0Aweight%3A+100%0Adescription%3A+%3E-%0A+++++Page+description+for+heading+and+indexes.%0A---%0A%0A%23%23+Heading%0A%0AEdit+this+template+to+create+your+new+page.%0A%0A%2A+Give+it+a+good+name%2C+ending+in+%60.md%60+-+e.g.+%60getting-started.md%60%0A%2A+Edit+the+%22front+matter%22+section+at+the+top+of+the+page+%28weight+controls+how+its+ordered+amongst+other+pages+in+the+same+directory%3B+lowest+number+first%29.%0A%2A+Add+a+good+commit+message+at+the+bottom+of+the+page+%28%3C80+characters%3B+use+the+extended+description+field+for+more+detail%29.%0A%2A+Create+a+new+branch+so+you+can+preview+your+new+file+and+request+a+review+via+Pull+Request.%0A" class=td-page-meta--child target=_blank rel=noopener><i class="fa-solid fa-pen-to-square fa-fw"></i> Create child page</a>
<a href="https://github.com/astro-xao/protocolbuffers.github.io//issues/new?title=%e7%bc%96%e7%a0%81" class=td-page-meta--issue target=_blank rel=noopener><i class="fa-solid fa-list-check fa-fw"></i> Create documentation issue</a>
<a href=https://github.com/protocolbuffers/protobuf/issues/new class=td-page-meta--project-issue target=_blank rel=noopener><i class="fa-solid fa-list-check fa-fw"></i> Create project issue</a></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#simple>一个简单的消息</a></li><li><a href=#varints>基于 128 的变长整数（Varint）</a></li><li><a href=#structure>消息结构</a></li><li><a href=#int-types>更多整数类型</a><ul><li><a href=#bools-and-enums>布尔和枚举</a></li><li><a href=#signed-ints>有符号整数</a></li><li><a href=#non-varints>非 varint 数字类型</a></li></ul></li><li><a href=#length-types>长度前缀记录</a><ul><li><a href=#embedded>子消息</a></li></ul></li><li><a href=#optional>缺失元素</a></li><li><a href=#repeated>重复元素</a><ul><li><a href=#oneofs>Oneof</a></li><li><a href=#last-one-wins>最后一个获胜</a></li><li><a href=#maps>Map</a></li></ul></li><li><a href=#groups>Groups</a></li><li><a href=#order>字段顺序</a><ul><li><a href=#implications>含义</a></li></ul></li><li><a href=#size-limit>编码 proto 的大小限制</a></li><li><a href=#cheat-sheet>速查表</a><ul><li><a href=#cheat-sheet-key>关键说明</a></li></ul></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><nav aria-label=breadcrumb class=td-breadcrumbs><ol class=breadcrumb><li class=breadcrumb-item><a href=/protocolbuffers.github.io/programming-guides/>编程指南</a></li><li class="breadcrumb-item active" aria-current=page>编码</li></ol></nav><div class=td-content><h1>编码</h1><div class=lead>解释 Protocol Buffers 如何将数据编码到文件或传输到网络。</div><header class=article-meta></header><p>本文档介绍了 protocol buffer 的<em>线格式</em>（wire format），它定义了消息在网络上传输和在磁盘上占用空间的详细方式。你在应用中使用 protocol buffer 时通常不需要了解这些细节，但如果你需要做优化，这些信息会很有用。</p><p>如果你已经了解相关概念但需要参考资料，可以直接跳到<a href=#cheat-sheet>速查表</a>部分。</p><p><a href=https://github.com/protocolbuffers/protoscope>Protoscope</a> 是一种非常简单的语言，用于描述底层线格式的片段，我们将用它来为各种消息的编码提供可视化参考。Protoscope 的语法由一系列<em>标记</em>（token）组成，每个标记都精确编码为特定的字节序列。</p><p>例如，反引号用于表示原始十六进制字面量，如 <code>`70726f746f6275660a`</code>。它会被编码为字面量中表示的确切字节。引号用于表示 UTF-8 字符串，如 <code>"Hello, Protobuf!"</code>。这个字面量等同于 <code>`48656c6c6f2c2050726f746f62756621`</code>（如果你仔细观察，会发现它由 ASCII 字节组成）。我们会在讨论线格式的过程中介绍更多 Protoscope 语言的内容。</p><p>Protoscope 工具还可以将已编码的 protocol buffer 以文本形式导出。参见 <a href=https://github.com/protocolbuffers/protoscope/tree/main/testdata>https://github.com/protocolbuffers/protoscope/tree/main/testdata</a> 获取示例。</p><p>本文所有示例均假设你使用的是 2023 版或更高版本。</p><h2 id=simple>一个简单的消息</h2><p>假设你有如下非常简单的消息定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test1</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>在应用中，你创建了一个 <code>Test1</code> 消息并将 <code>a</code> 设为 150。然后你将消息序列化到输出流。如果你能检查编码后的消息，你会看到三个字节：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>08</span> <span style=color:#0000cf;font-weight:700>96</span> <span style=color:#0000cf;font-weight:700>01</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>目前为止，看起来很小且全是数字——但这代表什么？如果你用 Protoscope 工具导出这些字节，你会看到类似 <code>1: 150</code> 的内容。它是如何知道消息内容的？</p><h2 id=varints>基于 128 的变长整数（Varint）</h2><p>变长整数（<em>varint</em>）是线格式的核心。它允许用 1 到 10 个字节编码无符号 64 位整数，较小的值使用更少的字节。</p><p>varint 的每个字节都有一个<em>续位</em>，用于指示后面的字节是否属于同一个 varint。这个续位是字节的<em>最高有效位</em>（MSB，有时也叫<em>符号位</em>）。低 7 位是有效载荷；最终的整数通过将各字节的 7 位有效载荷拼接起来得到。</p><p>例如，数字 1 编码为 <code>`01`</code>——它只有一个字节，所以 MSB 没有被设置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>0000</span> <span style=color:#0000cf;font-weight:700>0001</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>^</span> <span style=color:#000>msb</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>而 150 编码为 <code>`9601`</code>——稍微复杂一些：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>10010110</span> <span style=color:#0000cf;font-weight:700>00000001</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000>^</span> <span style=color:#000>msb</span>    <span style=color:#a40000>^</span> <span style=color:#000>msb</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>如何确定这是 150？首先去掉每个字节的 MSB，因为它只是用来告诉我们数字是否结束（如你所见，第一个字节的 MSB 被设置，表示 varint 不止一个字节）。这些 7 位有效载荷是小端序。转换为大端序，拼接后按无符号 64 位整数解释：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>10010110</span> <span style=color:#0000cf;font-weight:700>00000001</span>        <span style=color:#8f5902;font-style:italic>// 原始输入
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>0010110</span>  <span style=color:#0000cf;font-weight:700>0000001</span>        <span style=color:#8f5902;font-style:italic>// 去掉续位
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>0000001</span>  <span style=color:#0000cf;font-weight:700>0010110</span>        <span style=color:#8f5902;font-style:italic>// 转为大端序
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span>   <span style=color:#0000cf;font-weight:700>00000010010110</span>        <span style=color:#8f5902;font-style:italic>// 拼接
</span></span></span><span style=display:flex><span><span style=color:#8f5902;font-style:italic></span> <span style=color:#0000cf;font-weight:700>128</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>16</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>2</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>150</span>  <span style=color:#8f5902;font-style:italic>// 解释为无符号 64 位整数
</span></span></span></code></pre></div><p>由于 varint 对 protocol buffer 至关重要，在 protoscope 语法中，我们直接用整数表示 varint。<code>150</code> 就等同于 <code>`9601`</code>。</p><h2 id=structure>消息结构</h2><p>protocol buffer 消息是一系列键值对。消息的二进制版本只用字段号作为键——字段的名称和声明类型只能在解码端通过消息类型定义（即 <code>.proto</code> 文件）确定。Protoscope 无法获取这些信息，因此只能提供字段号。</p><p>消息编码时，每个键值对会被转换为一个<em>记录</em>，包含字段号、线类型和有效载荷。线类型告诉解析器后面的有效载荷有多大。这允许旧的解析器跳过它们不理解的新字段。这种方案有时被称为<a href=https://zh.wikipedia.org/wiki/Type%E2%80%93length%E2%80%93value>标签-长度-值</a>（TLV）。</p><p>线类型有六种：<code>VARINT</code>、<code>I64</code>、<code>LEN</code>、<code>SGROUP</code>、<code>EGROUP</code> 和 <code>I32</code></p><table><thead><tr><th>ID</th><th>名称</th><th>用于</th></tr></thead><tbody><tr><td>0</td><td>VARINT</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>I64</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>LEN</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>SGROUP</td><td>group start（已弃用）</td></tr><tr><td>4</td><td>EGROUP</td><td>group end（已弃用）</td></tr><tr><td>5</td><td>I32</td><td>fixed32, sfixed32, float</td></tr></tbody></table><p>记录的“标签”通过字段号和线类型组合成一个 varint，公式为 <code>(field_number &lt;&lt; 3) | wire_type</code>。换句话说，解码表示字段的 varint 后，低 3 位是线类型，其余位是字段号。</p><p>让我们再看一下前面的简单例子。你现在知道流中的第一个数字总是 varint 键，这里是 <code>`08`</code>，去掉 MSB 后：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>000</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>取最后三位得到线类型（0），右移三位得到字段号（1）。Protoscope 用整数加冒号和线类型表示标签，所以这些字节可以写作 <code>1:VARINT</code>。</p><p>因为线类型是 0，即 <code>VARINT</code>，我们知道需要解码一个 varint 作为有效载荷。如上所述，字节 <code>`9601`</code> 解码为 150，得到我们的记录。用 Protoscope 表示为 <code>1:VARINT 150</code>。</p><p>如果标签后有空格，Protoscope 可以推断类型。它会查看下一个标记并猜测你的意图（详细规则见 <a href=https://github.com/protocolbuffers/protoscope/blob/main/language.txt>Protoscope&rsquo;s language.txt</a>）。例如，<code>1: 150</code> 后面紧跟 varint，Protoscope 推断类型为 <code>VARINT</code>。如果写 <code>2: {}</code>，它看到 <code>{</code> 会猜测为 <code>LEN</code>；写 <code>3: 5i32</code> 会猜测为 <code>I32</code>，等等。</p><h2 id=int-types>更多整数类型</h2><h3 id=bools-and-enums>布尔和枚举</h3><p>布尔和枚举都按 <code>int32</code> 编码。布尔值总是编码为 <code>`00`</code> 或 <code>`01`</code>。在 Protoscope 中，<code>false</code> 和 <code>true</code> 是这两个字节串的别名。</p><h3 id=signed-ints>有符号整数</h3><p>如前所述，所有与线类型 0 相关的 protocol buffer 类型都按 varint 编码。但 varint 是无符号的，所以不同的有符号类型（<code>sint32</code>、<code>sint64</code> 与 <code>int32</code>、<code>int64</code>）对负数的编码方式不同。</p><p><code>intN</code> 类型将负数按二进制补码编码，这意味着作为无符号 64 位整数时，其最高位被设置。因此，<em>必须使用全部十个字节</em>。例如，<code>-2</code> 被 protoscope 转换为</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>11111110</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>11111111</span> <span style=color:#0000cf;font-weight:700>00000001</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>这是 2 的<em>二进制补码</em>，在无符号运算中定义为 <code>~0 - 2 + 1</code>，其中 <code>~0</code> 是全 1 的 64 位整数。理解为什么会产生这么多 1 是一个有趣的练习。</p><p><code>sintN</code> 使用“ZigZag”编码而不是二进制补码来编码负数。正整数 <code>p</code> 编码为 <code>2 * p</code>（偶数），负整数 <code>n</code> 编码为 <code>2 * |n| - 1</code>（奇数）。编码结果在正负数之间“之”字形切换。例如：</p><table><thead><tr><th>原始有符号值</th><th>编码后</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td>0x7fffffff</td><td>0xfffffffe</td></tr><tr><td>-0x80000000</td><td>0xffffffff</td></tr></tbody></table><p>换句话说，每个值 <code>n</code> 的编码方式为</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)
</span></span></code></pre></div><p>对于 <code>sint32</code>，或</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>(n &lt;&lt; 1) ^ (n &gt;&gt; 63)
</span></span></code></pre></div><p>用于 64 位版本。</p><p>解析 <code>sint32</code> 或 <code>sint64</code> 时，会将其值解码回原始有符号值。</p><p>在 protoscope 中，整数后缀 <code>z</code> 表示用 ZigZag 编码。例如，<code>-500z</code> 等同于 varint <code>999</code>。</p><h3 id=non-varints>非 varint 数字类型</h3><p>非 varint 数值类型很简单——<code>double</code> 和 <code>fixed64</code> 使用线类型 <code>I64</code>，告诉解析器后面是固定的 8 字节数据。我们可以用 <code>5: 25.4</code> 指定一个 <code>double</code> 记录，或用 <code>6: 200i64</code> 指定一个 <code>fixed64</code> 记录。两种情况下，省略显式线类型会默认推断为 <code>I64</code>。</p><p>同理，<code>float</code> 和 <code>fixed32</code> 使用线类型 <code>I32</code>，表示后面是 4 字节。语法是在数字后加 <code>i32</code> 后缀。<code>25.4i32</code> 和 <code>200i32</code> 都会输出 4 字节。标签类型会被推断为 <code>I32</code>。</p><h2 id=length-types>长度前缀记录</h2><p><em>长度前缀</em>是线格式中的另一个重要概念。<code>LEN</code> 线类型的长度是动态的，由标签后紧跟的 varint 指定，然后是有效载荷。</p><p>考虑如下消息结构：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test2</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>b</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>字段 <code>b</code> 是字符串，字符串用 <code>LEN</code> 编码。如果我们将 <code>b</code> 设为 <code>"testing"</code>，它会被编码为字段号 2 的 <code>LEN</code> 记录，内容为 ASCII 字符串 <code>"testing"</code>。结果是 <code>`120774657374696e67`</code>。拆分字节如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>12</span> <span style=color:#0000cf;font-weight:700>07</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>74</span> <span style=color:#0000cf;font-weight:700>65</span> <span style=color:#0000cf;font-weight:700>73</span> <span style=color:#0000cf;font-weight:700>74</span> <span style=color:#0000cf;font-weight:700>69</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000>e</span> <span style=color:#0000cf;font-weight:700>67</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>标签 <code>`12`</code> 是 <code>00010 010</code>，即 <code>2:LEN</code>。后面的字节是 int32 varint <code>7</code>，再后面七个字节是 <code>"testing"</code> 的 UTF-8 编码。int32 varint 意味着字符串最大长度为 2GB。</p><p>在 Protoscope 中，这写作 <code>2:LEN 7 "testing"</code>。不过，重复写字符串长度可能不方便（在 Protoscope 文本中，字符串已经用引号包裹）。用大括号包裹 Protoscope 内容会自动生成长度前缀：<code>{"testing"}</code> 等价于 <code>7 "testing"</code>。<code>{}</code> 总是被字段推断为 <code>LEN</code> 记录，所以可以简写为 <code>2: {"testing"}</code>。</p><p><code>bytes</code> 字段编码方式相同。</p><h3 id=embedded>子消息</h3><p>子消息字段同样使用 <code>LEN</code> 线类型。下面是一个嵌套了我们最初例子消息 <code>Test1</code> 的消息定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test3</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#000>Test1</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>如果 <code>Test1</code> 的 <code>a</code> 字段（即 <code>Test3</code> 的 <code>c.a</code> 字段）设为 150，编码结果为 <code>1a03089601</code>。拆分如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000>a</span> <span style=color:#0000cf;font-weight:700>03</span> <span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>08</span> <span style=color:#0000cf;font-weight:700>96</span> <span style=color:#0000cf;font-weight:700>01</span><span style=color:#000;font-weight:700>]</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>最后三个字节（<code>[]</code> 内）正好是我们<a href=#simple>第一个例子</a>中的字节。这些字节前面是一个 <code>LEN</code> 类型标签和长度 3，与字符串编码方式完全相同。</p><p>在 Protoscope 中，子消息写法非常简洁。<code>1a03089601</code> 可写作 <code>3: {1: 150}</code>。</p><h2 id=optional>缺失元素</h2><p>缺失字段的编码很简单：如果字段不存在，就不写入记录。这意味着“庞大”的 proto 只要设置了少量字段，编码结果会非常稀疏。</p><p><span id=packed></span></p><h2 id=repeated>重复元素</h2><p>从 2023 版开始，原始类型的 <code>repeated</code> 字段（任何<a href=./programming-guides/proto2#scalar>标量类型</a>，不包括 <code>string</code> 或 <code>bytes</code>）默认采用<a href=./editions/features#repeated_field_encoding>打包</a>编码。</p><p>打包的 <code>repeated</code> 字段不会为每个元素单独编码记录，而是编码为一个包含所有元素的 <code>LEN</code> 记录。解码时，从 <code>LEN</code> 记录中依次解出每个元素，直到有效载荷耗尽。下一个元素的起始位置由前一个元素的长度决定，而长度又取决于字段类型。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test4</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>d</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>4</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>repeated</span> <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>e</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>6</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>我们构造一个 <code>Test4</code> 消息，<code>d</code> 设为 <code>"hello"</code>，<code>e</code> 设为 <code>1</code>、<code>2</code>、<code>3</code>，编码结果<em>可能</em>为 <code>`3206038e029ea705`</code>，Protoscope 写法为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;hello&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>270</span> <span style=color:#0000cf;font-weight:700>86942</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>但如果 repeated 字段被设置为展开（覆盖默认打包状态）或不可打包（如字符串和消息），则每个值单独编码记录。并且，<code>e</code> 的记录不必连续出现，可以与其他字段交错；只有同一字段的记录顺序被保留。因此，也可以这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>4</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;hello&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>只有原始数值类型的 repeated 字段可以声明为“打包”。这些类型通常使用 <code>VARINT</code>、<code>I32</code> 或 <code>I64</code> 线类型。</p><p>注意，虽然通常没有必要为打包 repeated 字段编码多个键值对，但解析器必须能接受多个键值对。在这种情况下，有效载荷应当拼接。每对必须包含完整数量的元素。如下编码也是有效的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>3</span> <span style=color:#0000cf;font-weight:700>270</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>6</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#0000cf;font-weight:700>86942</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>protocol buffer 解析器必须能将打包和非打包 repeated 字段互相兼容解析。这允许你在向现有字段添加 <code>[packed=true]</code> 时保持前后兼容。</p><h3 id=oneofs>Oneof</h3><p><a href=./programming-guides/proto2#oneof><code>Oneof</code> 字段</a>的编码方式与不在 oneof 中时相同。oneof 的规则与其在线格式上的表示无关。</p><h3 id=last-one-wins>最后一个获胜</h3><p>通常，编码消息不会有多个非 repeated 字段实例。但解析器应能处理这种情况。对于数值类型和字符串，如果同一字段出现多次，解析器接受<em>最后</em>出现的值。对于嵌套消息字段，解析器会合并同一字段的多个实例，类似于 <code>Message::MergeFrom</code> 方法——即后一个实例的所有单一标量字段替换前一个，单一嵌套消息合并，repeated 字段拼接。这样，解析两个编码消息的拼接结果与分别解析后合并对象的结果完全一致。即：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#000>MyMessage</span> <span style=color:#000>message</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str1</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#000>str2</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>等价于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#000>MyMessage</span> <span style=color:#000>message</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>message2</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str1</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>message2</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ParseFromString</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>str2</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span><span style=color:#000>message</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>MergeFrom</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>message2</span><span style=color:#000;font-weight:700>);</span>
</span></span></code></pre></div><p>这个特性有时很有用，因为即使你不知道消息类型，也可以通过拼接合并两个消息。</p><h3 id=maps>Map</h3><p>Map 字段只是特殊 repeated 字段的简写。如果有</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test6</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#000>map</span><span style=color:#000;font-weight:700>&lt;</span><span style=color:#204a87;font-weight:700>string</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int32</span><span style=color:#000;font-weight:700>&gt;</span> <span style=color:#000>g</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>实际上等同于</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>Test6</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>message</span> <span style=color:#000>g_Entry</span> <span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>    <span style=color:#204a87;font-weight:700>string</span> <span style=color:#000>key</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>    <span style=color:#204a87;font-weight:700>int32</span> <span style=color:#000>value</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#204a87;font-weight:700>repeated</span> <span style=color:#000>g_Entry</span> <span style=color:#000>g</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>7</span><span style=color:#000;font-weight:700>;</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>因此，map 的编码方式与 repeated 消息字段完全相同：作为一系列 <code>LEN</code> 类型记录，每条记录有两个字段。</p><h2 id=groups>Groups</h2><p>Groups 是已弃用的特性，不应再使用，但它们仍然存在于线格式中，这里简单介绍一下。</p><p>Group 有点像子消息，但用特殊标签而不是 <code>LEN</code> 前缀分隔。每个 group 在消息中有一个字段号，用于这些特殊标签。</p><p>字段号为 <code>8</code> 的 group 以 <code>8:SGROUP</code> 标签开始。<code>SGROUP</code> 记录没有有效载荷，仅表示 group 开始。列出 group 内所有字段后，用对应的 <code>8:EGROUP</code> 标签结束。<code>EGROUP</code> 记录也没有有效载荷，所以 <code>8:EGROUP</code> 就是整个记录。group 字段号必须匹配。如果遇到 <code>7:EGROUP</code> 而期望 <code>8:EGROUP</code>，消息格式错误。</p><p>Protoscope 提供了便捷的 group 写法。你可以不用写</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span><span style=color:#000>SGROUP</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>3</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;foo&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span><span style=color:#000>EGROUP</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>而直接写</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-proto data-lang=proto><span style=display:flex><span><span style=color:#0000cf;font-weight:700>8</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#a40000>!</span><span style=color:#000;font-weight:700>{</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>1</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span>  <span style=color:#0000cf;font-weight:700>3</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000;font-weight:700>{</span><span style=color:#4e9a06>&#34;foo&#34;</span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#000;font-weight:700>}</span><span style=color:#a40000>
</span></span></span></code></pre></div><p>这会自动生成合适的 group 起止标记。<code>!{}</code> 语法只能紧跟未指定类型的标签表达式，如 <code>8:</code>。</p><h2 id=order>字段顺序</h2><p>字段号在 <code>.proto</code> 文件中可以任意顺序声明。顺序不会影响消息的序列化方式。</p><p>消息序列化时，已知或<a href=./programming-guides/proto2#updating>未知字段</a>的顺序没有保证。序列化顺序是实现细节，具体实现可能随时变化。因此，protocol buffer 解析器必须能解析任意顺序的字段。</p><h3 id=implications>含义</h3><ul><li>不要假设序列化消息的字节输出是稳定的。对于包含其他 protocol buffer 消息的字节字段的消息尤其如此。</li><li>默认情况下，对同一 protocol buffer 消息实例重复调用序列化方法，可能不会产生相同的字节输出。即，默认序列化不是确定性的。<ul><li>确定性序列化只保证同一二进制文件的输出一致。不同版本的二进制文件输出可能不同。</li></ul></li><li>以下检查对于 protocol buffer 消息实例 <code>foo</code> 可能失败：<ul><li><code>foo.SerializeAsString() == foo.SerializeAsString()</code></li><li><code>Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString())</code></li><li><code>CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString())</code></li><li><code>FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString())</code></li></ul></li><li>以下场景中，逻辑等价的 protocol buffer 消息 <code>foo</code> 和 <code>bar</code> 可能序列化为不同的字节输出：<ul><li><code>bar</code> 由旧服务器序列化，部分字段被视为未知。</li><li><code>bar</code> 由不同编程语言实现的服务器序列化，字段顺序不同。</li><li><code>bar</code> 有字段以非确定性方式序列化。</li><li><code>bar</code> 有字段存储了 protocol buffer 消息的序列化字节输出，而该消息序列化方式不同。</li><li><code>bar</code> 由新服务器序列化，因实现变更字段顺序不同。</li><li><code>foo</code> 和 <code>bar</code> 是同一组消息以不同顺序拼接的结果。</li></ul></li></ul><h2 id=size-limit>编码 proto 的大小限制</h2><p>序列化后的 proto 必须小于 2 GiB。许多 proto 实现会拒绝序列化或解析超过此限制的消息。</p><h2 id=cheat-sheet>速查表</h2><p>以下是线格式最重要部分的便捷参考。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#000>message</span>    <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>tag</span> <span style=color:#000>value</span><span style=color:#000;font-weight:700>)</span><span style=color:#ce5c00;font-weight:700>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>tag</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>field</span> <span style=color:#ce5c00;font-weight:700>&lt;&lt;</span> <span style=color:#0000cf;font-weight:700>3</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>bit</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#204a87;font-weight:700>or</span> <span style=color:#000>wire_type</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>编码为</span> <span style=color:#000>uint32</span> <span style=color:#000>varint</span>
</span></span><span style=display:flex><span><span style=color:#000>value</span>      <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>varint</span>      <span style=color:#a40000>当</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>VARINT</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>i32</span>         <span style=color:#a40000>当</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>I32</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>i64</span>         <span style=color:#a40000>当</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>I64</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>prefix</span>  <span style=color:#a40000>当</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>LEN</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>              <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>empty</span><span style=color:#ce5c00;font-weight:700>&gt;</span>     <span style=color:#a40000>当</span> <span style=color:#000>wire_type</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>SGROUP</span> <span style=color:#a40000>或</span> <span style=color:#000>EGROUP</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>varint</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>int32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>int64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>uint32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>uint64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#c00;font-weight:700>bool</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#204a87;font-weight:700>enum</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>sint32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>sint64</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>编码为</span> <span style=color:#000>varint</span><span style=color:#a40000>（</span><span style=color:#000>sintN</span> <span style=color:#a40000>先用</span> <span style=color:#000>ZigZag</span> <span style=color:#a40000>编码）</span>
</span></span><span style=display:flex><span><span style=color:#000>i32</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>sfixed32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>fixed32</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#c00;font-weight:700>float</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>编码为</span> <span style=color:#0000cf;font-weight:700>4</span> <span style=color:#a40000>字节小端序；</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>等价</span> <span style=color:#000>C</span> <span style=color:#a40000>类型（</span><span style=color:#000>u</span><span style=color:#a40000>?</span><span style=color:#000>int32_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#c00;font-weight:700>float</span><span style=color:#a40000>）的</span> <span style=color:#000>memcpy</span>
</span></span><span style=display:flex><span><span style=color:#000>i64</span>        <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>sfixed64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>fixed64</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>double</span><span style=color:#000;font-weight:700>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>编码为</span> <span style=color:#0000cf;font-weight:700>8</span> <span style=color:#a40000>字节小端序；</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>等价</span> <span style=color:#000>C</span> <span style=color:#a40000>类型（</span><span style=color:#000>u</span><span style=color:#a40000>?</span><span style=color:#000>int64_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>double</span><span style=color:#a40000>）的</span> <span style=color:#000>memcpy</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000>len</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>prefix</span> <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>size</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>message</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>string</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>bytes</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>packed</span><span style=color:#000;font-weight:700>);</span>
</span></span><span style=display:flex><span>                <span style=color:#000>size</span> <span style=color:#a40000>编码为</span> <span style=color:#000>int32</span> <span style=color:#000>varint</span>
</span></span><span style=display:flex><span><span style=color:#000>string</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#a40000>有效</span> <span style=color:#000>UTF</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>8</span> <span style=color:#a40000>字符串（如</span> <span style=color:#000>ASCII</span><span style=color:#a40000>）；</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>最多</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>GB</span> <span style=color:#a40000>字节</span>
</span></span><span style=display:flex><span><span style=color:#000>bytes</span>      <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#a40000>任意</span> <span style=color:#0000cf;font-weight:700>8</span> <span style=color:#a40000>位字节序列；</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>最多</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000>GB</span> <span style=color:#a40000>字节</span>
</span></span><span style=display:flex><span><span style=color:#000>packed</span>     <span style=color:#000;font-weight:700>:</span><span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>varint</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>i32</span><span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>i64</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>,</span>
</span></span><span style=display:flex><span>                <span style=color:#a40000>`</span><span style=color:#ce5c00;font-weight:700>.</span><span style=color:#000>proto</span><span style=color:#a40000>`</span> <span style=color:#a40000>中指定类型的连续值</span>
</span></span></code></pre></div><p>另见
<a href=https://github.com/protocolbuffers/protoscope/blob/main/language.txt>Protoscope 语言参考</a>。</p><h3 id=cheat-sheet-key>关键说明</h3><dl><dt><code>message := (tag value)*</code></dt><dd>一条消息编码为零个或多个标签和值对。</dd><dt><code>tag := (field &lt;&lt; 3) bit-or wire_type</code></dt><dd>标签由 <code>wire_type</code>（最低三位）和 <code>.proto</code> 文件中定义的字段号组合而成。</dd><dt><code>value := varint 当 wire_type == VARINT, ...</code></dt><dd>值的存储方式取决于标签中指定的 <code>wire_type</code>。</dd><dt><code>varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64</code></dt><dd>varint 可用于存储上述任意类型。</dd><dt><code>i32 := sfixed32 | fixed32 | float</code></dt><dd>fixed32 可用于存储上述任意类型。</dd><dt><code>i64 := sfixed64 | fixed64 | double</code></dt><dd>fixed64 可用于存储上述任意类型。</dd><dt><code>len-prefix := size (message | string | bytes | packed)</code></dt><dd>长度前缀值存储为长度（编码为 varint），后跟上述任意类型。</dd><dt><code>string := 有效 UTF-8 字符串（如 ASCII）</code></dt><dd>字符串必须使用 UTF-8 编码，最大不能超过 2GB。</dd><dt><code>bytes := 任意 8 位字节序列</code></dt><dd>bytes 可存储自定义数据类型，最大 2GB。</dd><dt><code>packed := varint* | i32* | i64*</code></dt><dd>当你需要存储 <code>.proto</code> 定义类型的连续值时使用 packed。标签只在第一个值前出现一次，后续值不再重复标签，从而摊薄标签开销。</dd></dl></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2025 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/protocolbuffers.github.io/js/main.min.465e525b7f12005beca2f93e7a2facf1d7da354d8fa99daffa84ddbfba25da98.js integrity="sha256-Rl5SW38SAFvsovk+ei+s8dfaNU2PqZ2v+oTdv7ol2pg=" crossorigin=anonymous></script><script defer src=/protocolbuffers.github.io/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/protocolbuffers.github.io/js/tabpane-persist.js></script></body></html>