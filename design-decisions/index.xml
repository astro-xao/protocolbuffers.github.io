<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protobuf 团队设计决策 on Protocol Buffers Documentation</title><link>https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/</link><description>Recent content in Protobuf 团队设计决策 on Protocol Buffers Documentation</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/index.xml" rel="self" type="application/rss+xml"/><item><title>不支持可空 Setter/Getters</title><link>https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/nullable-getters-setters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/nullable-getters-setters/</guid><description>我们收到了一些反馈，有开发者希望 protobuf 能在他们所用的支持 null 的语言（尤其是 Kotlin、C# 和 Rust）中支持可空的 getter/setter。虽然这对这些语言的用户来说似乎是一个有用的特性，但这种设计选择存在权衡，因此 Protobuf 团队选择不予实现。
不支持可空字段的最大原因在于 .proto 文件中指定的默认值的预期行为。按照设计，调用未设置字段的 getter 时会返回该字段的默认值。
注意： C# 确实将 message 字段视为可空。这与其他语言的不一致，源于缺乏不可变消息，这使得无法创建可共享的不可变默认实例。由于 message 字段不能有默认值，因此这不会带来实际问题。
举个例子，假设有如下 .proto 文件：
message Msg { optional Child child = 1; } message Child { optional Grandchild grandchild = 1; } message Grandchild { optional int32 foo = 1 [default = 72]; } 以及对应的 Kotlin getter：
// 在我们的 API 中，getter 总是非空的： msg.child.grandchild.foo == 72 // 如果子消息是可空的，?. 操作符无法获取默认值： msg?</description></item></channel></rss>