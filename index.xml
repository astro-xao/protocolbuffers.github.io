<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protocol Buffer on Protocol Buffers 文档</title><link>https://astro-xao.github.io/protocolbuffers.github.io/</link><description>Recent content in Protocol Buffer on Protocol Buffers 文档</description><generator>Hugo</generator><language>en</language><atom:link href="https://astro-xao.github.io/protocolbuffers.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>概述</title><link>https://astro-xao.github.io/protocolbuffers.github.io/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/overview/</guid><description>它类似于 JSON，但更小、更快，并且可以生成原生语言绑定。你只需定义一次数据结构，然后就可以使用专门生成的源代码，轻松地将结构化数据读写到各种数据流中，并支持多种编程语言。
Protocol Buffers 包含定义语言（在 .proto 文件中创建）、proto 编译器生成的用于与数据交互的代码、语言特定的运行时库、用于写入文件（或通过网络连接发送）的序列化格式，以及序列化后的数据。
Protocol Buffers 解决了哪些问题？ Protocol Buffers 提供了一种用于类型化、结构化数据包的序列化格式，适用于几兆字节以内的数据。该格式既适用于临时网络通信，也适用于长期数据存储。Protocol Buffers 可以通过添加新信息进行扩展，而不会使现有数据失效或需要更新代码。
Protocol Buffers 是 Google 内部最常用的数据格式，广泛用于服务器间通信以及磁盘上的数据归档存储。Protocol Buffer 的 消息 和 服务 由工程师编写的 .proto 文件描述。以下是一个 message 示例：
edition = &amp;#34;2023&amp;#34;; message Person { string name = 1; int32 id = 2; string email = 3; } 在构建时，proto 编译器会对 .proto 文件进行处理，生成用于操作对应 Protocol Buffer 的多种编程语言代码（详见后文 跨语言兼容性）。每个生成的类都包含对每个字段的简单访问器，以及用于将整个结构序列化和解析为原始字节的方法。以下是使用这些生成方法的示例：
Person john = Person.newBuilder() .setId(1234) .setName(&amp;#34;John Doe&amp;#34;) .setEmail(&amp;#34;jdoe@example.com&amp;#34;) .build(); output = new FileOutputStream(args[0]); john.</description></item><item><title>Protocol Buffer 编译器安装</title><link>https://astro-xao.github.io/protocolbuffers.github.io/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/installation/</guid><description>Protocol Buffer 编译器 protoc 用于编译包含服务和消息定义的 .proto 文件。请选择以下方法之一安装 protoc。
安装预编译二进制文件（任意操作系统） 要从预编译的二进制文件安装协议编译器的最新版本，请按照以下步骤操作：
访问 https://github.com/google/protobuf/releases，手动下载与你的操作系统和计算机架构对应的 zip 文件（protoc-&amp;lt;version&amp;gt;-&amp;lt;os&amp;gt;-&amp;lt;arch&amp;gt;.zip），或使用如下命令获取文件：
PB_REL=&amp;#34;https://github.com/protocolbuffers/protobuf/releases&amp;#34; curl -LO $PB_REL/download/v30.2/protoc-30.2-linux-x86_64.zip 将文件解压到 $HOME/.local 或你选择的目录。例如：
unzip protoc-30.2-linux-x86_64.zip -d $HOME/.local 更新你的环境变量 PATH，将 protoc 可执行文件所在路径加入。例如：
export PATH=&amp;#34;$PATH:$HOME/.local/bin&amp;#34; 使用包管理器安装 警告 使用包管理器安装后，请运行 protoc --version 检查 protoc 的版本，确保其足够新。某些包管理器安装的 protoc 版本可能较旧。请参阅 版本支持页面 对比你的版本号与所用语言支持的次版本号。 你可以在 Linux、macOS 或 Windows 下使用包管理器安装协议编译器 protoc，命令如下。
Linux，使用 apt 或 apt-get，例如：
apt install -y protobuf-compiler protoc --version # 确保编译器版本为 3 及以上 MacOS，使用 Homebrew：
brew install protobuf protoc --version # 确保编译器版本为 3 及以上 Windows，使用 Winget</description></item><item><title>语言指南 (proto 2)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto2/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>语言指南 (proto 3)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto3/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 revision of the protocol buffers language.
For information on editions syntax, see the Protobuf Editions Language Guide.
For information on the proto2 syntax, see the Proto2 Language Guide.
This is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.</description></item><item><title>语言指南(editions)</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/editions/</guid><description>This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers edition 2023 of the protocol buffers language. For information about how editions differ from proto2 and proto3 conceptually, see Protobuf Editions Overview.
For information on the proto2 syntax, see the Proto2 Language Guide.
For information on proto3 syntax, see the Proto3 Language Guide.</description></item><item><title>Protobuf Editions Overview</title><link>https://astro-xao.github.io/protocolbuffers.github.io/editions/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/editions/overview/</guid><description>Protobuf Editions replace the proto2 and proto3 designations that we have used for Protocol Buffers. Instead of adding syntax = &amp;quot;proto2&amp;quot; or syntax = &amp;quot;proto3&amp;quot; at the top of proto definition files, you use an edition number, such as edition = &amp;quot;2023&amp;quot;, to specify the default behaviors your file will have. Editions enable the language to evolve incrementally over time.
Instead of the hardcoded behaviors that older versions have had, editions represent a collection of features with a default value (behavior) per feature.</description></item><item><title>Feature Settings for Editions</title><link>https://astro-xao.github.io/protocolbuffers.github.io/editions/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/editions/features/</guid><description>This topic provides an overview of the features that are included in Edition 2023. Each subsequent edition&amp;rsquo;s features will be added to this topic. We announce new editions in the News section.
Before configuring feature settings in your new schema definition content, make sure you understand why you are using them. Avoid cargo-culting with features.
Prototiller Prototiller is a command-line tool that converts proto2 and proto3 definition files to Editions syntax.</description></item><item><title>Implementing Editions Support</title><link>https://astro-xao.github.io/protocolbuffers.github.io/editions/implementation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/editions/implementation/</guid><description>This topic explains how to implement editions in new runtimes and generators.
Overview Edition 2023 The first edition released is Edition 2023, which is designed to unify proto2 and proto3 syntax. The features we’ve added to cover the difference in behaviors are detailed in Feature Settings for Editions.
Feature Definition In addition to supporting editions and the global features we&amp;rsquo;ve defined, you may want to define your own features to leverage the infrastructure.</description></item><item><title>Proto 限制</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/proto-limits/</guid><description>本文档记录了 proto schema 中支持的元素数量（字段、枚举值等）的限制。
这些信息由许多工程师收集整理，但并不详尽，部分内容可能已过时或不准确。欢迎在工作中发现新的限制后，补充到本文档，帮助他人。
字段数量限制 仅包含单一 proto 字段（如 Boolean）的消息：
~2100 个字段（proto2） ~3100 个字段（proto3，未使用 optional 字段） 通过单一字段（如 Boolean）扩展的空消息：
~4100 个字段（proto2） proto3 不支持扩展。
要测试此限制，可创建一个超过上述上限字段数量的 proto 消息，并使用 Java proto 规则进行编译。该限制来源于 JVM 规范。
枚举值数量限制 最低限制约为 1700 个值（Java）。其他语言有不同的限制。
消息总大小限制 任何序列化形式的 proto 消息必须小于 2GiB，这是所有实现支持的最大大小。建议限制请求和响应的大小。
Proto 反序列化深度限制 Java： 100 C++： 100 Go： 10000 （计划将其减少到 100） 如果尝试反序列化嵌套深度超过限制的消息，反序列化将失败。</description></item><item><title>风格指南</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/style/</guid><description>本文档为 .proto 文件提供了风格指南。遵循这些约定，可以让您的协议缓冲区消息定义及其对应的类保持一致且易于阅读。
标准文件格式 保持每行长度不超过 80 个字符。 使用 2 个空格缩进。 字符串建议使用双引号。 文件结构 文件应命名为 lower_snake_case.proto。
所有文件应按以下顺序排列：
许可证头（如适用） 文件概述 语法声明 包声明 导入（排序） 文件选项 其他内容 标识符命名风格 Protobuf 标识符使用以下命名风格之一：
TitleCase 包含大写字母、小写字母和数字 首字母为大写字母 每个单词的首字母大写 lower_snake_case 包含小写字母、下划线和数字 单词之间用单个下划线分隔 UPPER_SNAKE_CASE 包含大写字母、下划线和数字 单词之间用单个下划线分隔 camelCase 包含大写字母、小写字母和数字 首字母为小写字母 每个后续单词的首字母大写 注意： 下述风格指南不建议在 .proto 文件中使用 camelCase，仅为说明某些语言生成的代码可能会将标识符转换为此风格。 所有情况下，缩写应视为单个单词：使用 GetDnsRequest 而不是 GetDNSRequest，使用 dns_request 而不是 d_n_s_request。
标识符中的下划线 不要在名称的开头或结尾使用下划线。任何下划线后面都应跟字母（而不是数字或第二个下划线）。
此规则的动机在于，每种 protobuf 语言实现可能会将标识符转换为本地语言风格：.proto 文件中的 song_id 字段在不同语言中可能分别变为 SongId、songId 或 song_id。
仅在字母前使用下划线，可以避免名称在一种风格下不同，但转换为另一种风格后发生冲突的情况。
例如，DNS2 和 DNS_2 转换为 TitleCase 都会变为 Dns2。允许这两种命名会导致在某些语言中生成的代码保持原有 UPPER_SNAKE_CASE 风格并广泛使用，后来在另一种语言中转换为 TitleCase 时发生冲突。</description></item><item><title>枚举行为</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/enum/</guid><description>不同语言库中枚举的行为各不相同。本主题介绍了这些不同的行为，以及将 protobufs 迁移到所有语言一致状态的计划。如果你想了解如何使用枚举，请参阅 proto2 和 proto3 语言指南中的相关章节。
定义 枚举有两种不同的类型（开放 和 封闭）。它们的行为完全相同，除了对未知值的处理方式不同。实际上，这意味着简单场景下行为一致，但某些边界情况会有有趣的影响。
为便于说明，假设我们有如下 .proto 文件（此处有意未指定 syntax = &amp;quot;proto2&amp;quot; 还是 syntax = &amp;quot;proto3&amp;quot;）：
enum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } 开放 和 封闭 的区别可以用一个问题来概括：
当程序解析包含字段 1 且值为 2 的二进制数据时会发生什么？
开放枚举会解析值 2 并直接存储在字段中。访问器会报告该字段已设置，并返回代表 2 的内容。 封闭枚举会解析值 2 并将其存储在消息的未知字段集中。访问器会报告该字段为未设置，并返回枚举的默认值。 封闭 枚举的影响 封闭 枚举在解析重复字段时会带来意想不到的后果。当解析 repeated Enum 字段时，所有未知值都会被放入 未知字段 集中。序列化时，这些未知值会被再次写出，但不会在原列表中的原始位置。例如，给定如下 .proto 文件：
enum Enum { A = 0; B = 1; } message Msg { repeated Enum r = 1; } 如果线格式包含字段 1 的值为 [0, 2, 1, 2]，则重复字段解析后为 [0, 1]，而 [2, 2] 会被存储为未知字段。重新序列化消息后，线格式将变为 [0, 1, 2, 2]。</description></item><item><title>Encoding</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/encoding/</guid><description>This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don&amp;rsquo;t need to understand this to use protocol buffers in your application, but it&amp;rsquo;s useful information for doing optimizations.
If you already know the concepts but want a reference, skip to the Condensed reference card section.
Protoscope is a very simple language for describing snippets of the low-level wire format, which we&amp;rsquo;ll use to provide a visual reference for the encoding of various messages.</description></item><item><title>ProtoJSON 格式</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/json/</guid><description>Protobuf 支持一种规范的 JSON 编码格式，使得与不支持标准 protobuf 二进制格式的系统之间的数据共享更加容易。
ProtoJSON 格式的效率不如 protobuf 二进制格式。转换器在编码和解码消息时会消耗更多的 CPU，并且（除极少数情况外）编码后的消息占用的空间也更大。此外，ProtoJSON 格式会将你的字段名和枚举值名写入编码消息，这会导致后续更改这些名称变得更加困难。移除字段会造成兼容性破坏，并触发解析错误。简而言之，Google 更倾向于在几乎所有场景下使用标准二进制格式而不是 ProtoJSON 格式，是有充分理由的。
各类型的编码方式将在后文的表格中详细说明。
当将 JSON 编码的数据解析为 protocol buffer 时，如果某个值缺失或其值为 null，则会被解释为对应的默认值。对于单个字段的多次赋值（使用重复或等价的 JSON 键），解析时会保留最后一个值，这与二进制格式解析一致。注意，并非所有 protobuf JSON 解析器实现都符合规范，一些不符合规范的实现可能会拒绝重复键。
当从 protocol buffer 生成 JSON 编码输出时，如果 protobuf 字段为默认值且不支持字段存在性（presence），则默认情况下不会在输出中包含该字段。实现可以提供选项，将默认值字段包含在输出中。
已设置值且支持字段存在性的字段，在 JSON 编码输出中总会包含该字段，即使其为默认值。例如，proto3 中用 optional 关键字定义的字段支持存在性，如果被设置，则总会出现在 JSON 输出中。任何版本的 protobuf 中的消息类型字段都支持存在性，如果被设置也会出现在输出中。proto3 中隐式存在性的标量字段，只有在其值不是该类型的默认值时才会出现在 JSON 输出中。
在 JSON 文件中表示数值数据时，如果从二进制格式解析出的数字不适合对应的类型，将会像在 C++ 中强制类型转换一样（例如，将 64 位数字读取为 int32 时会被截断为 32 位）。
下表展示了各类数据在 JSON 文件中的表示方式。
Protobuf JSON JSON 示例 说明 message object {"</description></item><item><title>技术技巧</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/techniques/</guid><description>你也可以将设计和使用相关的问题发送到 Protocol Buffers 讨论组。
常见文件名后缀 通常会以多种不同格式将消息写入文件。我们建议为这些文件使用以下扩展名。
内容 扩展名 文本格式 .txtpb 二进制格式 .binpb JSON 格式 .json 对于文本格式，.textproto 也很常见，但我们推荐使用 .txtpb，因为它更简洁。
多消息流式处理 如果你想将多个消息写入同一个文件或流，需要自己跟踪每个消息的起止位置。Protocol Buffer 的二进制格式不是自描述的，因此解析器无法自行判断消息的结束位置。最简单的解决方法是，在写入每个消息前先写入其大小。读取时，先读取大小，再将对应字节读入缓冲区，然后解析该缓冲区。（如果想避免复制字节到单独缓冲区，可以查看 CodedInputStream 类（C++ 和 Java 均有），它可以限制读取的字节数。）
大数据集 Protocol Buffers 并不适合处理大型消息。一般来说，如果每条消息超过 1MB，建议考虑其他方案。
不过，Protocol Buffers 非常适合处理大型数据集中的单条消息。通常，大型数据集由许多结构化的小数据组成。虽然 Protocol Buffers 无法一次处理整个数据集，但用它编码每个小数据块可以大大简化问题：你只需处理一组字节串，而不是一组结构体。
Protocol Buffers 没有内置对大数据集的支持，因为不同场景需要不同的解决方案。有时只需简单的记录列表，有时则需要类似数据库的结构。每种方案都应作为独立库开发，只有需要的人才需承担相应的成本。
自描述消息 Protocol Buffers 本身不包含类型描述。因此，仅凭原始消息而没有对应的 .proto 文件，很难提取有用数据。
不过，.proto 文件的内容本身可以用 Protocol Buffers 表示。源码包中的 src/google/protobuf/descriptor.proto 定义了相关消息类型。protoc 可以通过 --descriptor_set_out 选项输出 FileDescriptorSet，它表示一组 .proto 文件。你可以这样定义自描述协议消息：
syntax = &amp;#34;proto3&amp;#34;; import &amp;#34;google/protobuf/any.proto&amp;#34;; import &amp;#34;google/protobuf/descriptor.proto&amp;#34;; message SelfDescribingMessage { // 描述类型及其依赖的 FileDescriptorProto 集合。 google.</description></item><item><title>第三方插件</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/addons/</guid><description>许多开源项目致力于为 Protocol Buffers 增加有用的功能。要查看我们已知项目的链接列表，请参阅 第三方插件 Wiki 页面。</description></item><item><title>扩展声明</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/extension_declarations/</guid><description>简介 本页详细介绍了扩展声明是什么、为什么需要它们以及如何使用它们。
注意 Proto3 不支持扩展（除了声明自定义选项）。 扩展在 proto2 和 editions 中完全支持。 如果你需要扩展的入门介绍，请阅读此扩展指南
动机 扩展声明旨在在常规字段和扩展之间取得平衡。像扩展一样，它们避免了对字段消息类型的依赖，从而在难以或无法剥离未使用消息的环境中实现更精简的构建图和更小的二进制文件。像常规字段一样，字段名称/编号会出现在封闭消息中，这使得避免冲突和方便查看已声明字段列表变得更容易。
通过扩展声明列出已占用的扩展编号，使用户更容易选择可用的扩展编号并避免冲突。
用法 扩展声明是扩展范围的一种选项。类似于 C++ 的前向声明，你可以声明扩展字段的类型、字段名和基数（单个或重复），而无需导入包含完整扩展定义的 .proto 文件：
edition = &amp;#34;2023&amp;#34;; message Foo { extensions 4 to 1000 [ declaration = { number: 4, full_name: &amp;#34;.my.package.event_annotations&amp;#34;, type: &amp;#34;.logs.proto.ValidationAnnotations&amp;#34;, repeated: true }, declaration = { number: 999, full_name: &amp;#34;.foo.package.bar&amp;#34;, type: &amp;#34;int32&amp;#34;}]; } 该语法具有以下语义：
如果范围足够大，可以在单个扩展范围内定义多个具有不同扩展编号的 declaration。 如果扩展范围有任何声明，则该范围的所有扩展也必须声明。这可以防止添加未声明的扩展，并强制任何新扩展都使用声明。 给定的消息类型（如 .logs.proto.ValidationAnnotations）不需要事先定义或导入。只需检查它是否是一个有效的名称，可能在其他 .proto 文件中定义。 当此或其他 .proto 文件为该消息（Foo）定义扩展且名称或编号匹配时，将强制扩展的编号、类型和全名与此处的前向声明一致。 警告 避免对扩展范围组（如 extensions 4, 999）使用声明。目前尚不清楚声明适用于哪个扩展范围，并且目前不支持。 扩展声明期望有两个不同包的扩展字段：</description></item><item><title>Application Note: Field Presence</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/field_presence/</guid><description>Background Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: implicit presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.
Note We recommend always adding the optional label for proto3 basic types. This provides a smoother path to editions, which uses explicit presence by default.</description></item><item><title>Proto 序列化不是规范化的</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/serialization-not-canonical/</guid><description>许多人希望序列化后的 proto 能规范地代表其内容。常见用例包括：
将序列化的 proto 用作哈希表的键 对序列化的 proto 取指纹或校验和 通过比较序列化后的数据判断消息是否相等 不幸的是，protobuf 的序列化不是（也无法做到）规范化。虽然有一些特殊情况（如 MapReduce），但通常你应该认为 proto 的序列化结果是不稳定的。本文将解释原因。
确定性并不等于规范化 确定性序列化并不等于规范化。序列化器可能因多种原因生成不同的输出，包括但不限于以下变化：
protobuf 的 schema 发生任何变化。 构建的应用发生任何变化。 二进制文件使用不同的编译参数（如 opt 与 debug）。 protobuf 库被更新。 这意味着序列化 proto 的哈希值是脆弱的，无法在不同时间或空间保持稳定。
导致序列化输出变化的原因有很多，上述列表并不详尽。其中有些是该问题领域内固有的困难，即使我们想要，也难以保证规范化序列化。还有一些是我们有意未定义的，以便为优化留出空间。
稳定序列化的固有障碍 Protobuf 对象会保留未知字段，以实现前向和后向兼容性。未知字段无法规范化序列化：
未知字段无法区分字节和子消息，因为它们的 wire type 相同。这导致无法对存储在未知字段集中的消息进行规范化。如果要规范化，我们需要递归进入未知子消息并按字段号排序，但我们没有足够的信息来做到这一点。 未知字段总是在已知字段之后序列化，以提高效率。但规范化序列化要求按字段号将未知字段与已知字段交错序列化。这会给所有人带来效率和代码体积的开销，即使他们并未使用该特性。 有意未定义的内容 即使规范化序列化是可行的（即我们能解决未知字段问题），我们也会有意将序列化顺序未定义，以便获得更多优化空间：
如果我们能证明某个字段在二进制中从未被使用，可以将其从 schema 中完全移除，并作为未知字段处理。这能显著节省代码体积和 CPU 周期。 有时可以通过将同一字段的向量一起序列化来优化，尽管这会打破字段号顺序。 为了给这些优化留出空间，我们希望在某些配置下有意打乱字段顺序，防止应用错误地依赖字段顺序。</description></item><item><title>不支持可空 Setter/Getters</title><link>https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/nullable-getters-setters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/design-decisions/nullable-getters-setters/</guid><description>我们收到了一些反馈，有开发者希望 protobuf 能在他们所用的支持 null 的语言（尤其是 Kotlin、C# 和 Rust）中支持可空的 getter/setter。虽然这对这些语言的用户来说似乎是一个有用的特性，但这种设计选择存在权衡，因此 Protobuf 团队选择不予实现。
不支持可空字段的最大原因在于 .proto 文件中指定的默认值的预期行为。按照设计，调用未设置字段的 getter 时会返回该字段的默认值。
注意： C# 确实将 message 字段视为可空。这与其他语言的不一致，源于缺乏不可变消息，这使得无法创建可共享的不可变默认实例。由于 message 字段不能有默认值，因此这不会带来实际问题。
举个例子，假设有如下 .proto 文件：
message Msg { optional Child child = 1; } message Child { optional Grandchild grandchild = 1; } message Grandchild { optional int32 foo = 1 [default = 72]; } 以及对应的 Kotlin getter：
// 在我们的 API 中，getter 总是非空的： msg.child.grandchild.foo == 72 // 如果子消息是可空的，?. 操作符无法获取默认值： msg?</description></item><item><title>反序列化 Debug Proto 表示</title><link>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/programming-guides/deserialize-debug/</guid><description>从 30.x 版本开始，Protobuf 的 DebugString API（如 Message::DebugString、Message::ShortDebugString、Message::Utf8DebugString）、其他 Protobuf API（如 proto2::ShortFormat、proto2::Utf8Format）、Abseil 字符串函数（如 absl::StrCat、absl::StrFormat、absl::StrAppend 和 absl::Substitute），以及 Abseil 日志 API，将会自动把 proto 参数转换为新的调试格式。相关公告请参见这里。
与 Protobuf DebugString 输出格式不同，新的调试格式会自动将敏感字段的值替换为字符串 &amp;ldquo;[REDACTED]&amp;quot;（不带引号）。此外，为确保这种新的输出格式无法被 Protobuf TextFormat 解析器反序列化（无论底层 proto 是否包含 SPII 字段），我们会添加一组随机链接指向本文，并插入随机长度的空白序列。新的调试格式如下所示：
goo.gle/debugstr spii_field: [REDACTED] normal_field: &amp;#34;value&amp;#34; 请注意，新的调试格式与 DebugString 格式的输出仅有以下两点不同：
URL 前缀 SPII 字段的值被替换为 &amp;ldquo;[REDACTED]&amp;quot;（不带引号） 新的调试格式绝不会移除任何字段名；它只会在字段被认为是敏感时将其值替换为 &amp;ldquo;[REDACTED]&amp;quot;。 如果你在输出中没有看到某些字段，那是因为这些字段在 proto 中未被设置。
提示： 如果你只看到 URL 而没有其他内容，说明你的 proto 是空的！
为什么会有这个 URL？ 我们希望确保没有人将面向人类的 protobuf 消息可读表示反序列化。历史上，.DebugString() 和 TextFormat 是可以互换的，现有系统也常用 DebugString 来传输和存储数据。
我们希望敏感数据不会意外出现在日志中。因此，在将 protobuf 消息转换为字符串（&amp;quot;[REDACTED]&amp;quot;）之前，我们会自动对某些字段值进行脱敏。这降低了意外日志记录带来的安全和隐私风险，但如果其他系统反序列化你的消息，则可能导致数据丢失。为了解决这个风险，我们有意将机器可读的 TextFormat 与用于日志消息的人类可读调试格式分开。</description></item><item><title>Proto 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/dos-donts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/dos-donts/</guid><description>客户端和服务端永远不会在完全相同的时间更新——即使你尝试同时更新它们。某一方可能会被回滚。不要假设你可以做破坏性更改，并且客户端和服务端会保持同步。
不要重复使用标签号 绝不要重复使用标签号。这会导致反序列化出错。即使你认为没有人在用该字段，也不要重复使用标签号。如果更改曾经上线过，可能在某些日志中还存在序列化的 proto 版本。或者在其他服务器上的旧代码会因此崩溃。
要为已删除字段保留标签号 当你删除一个不再使用的字段时，应该保留其标签号，防止将来被误用。只需 reserved 2, 3; 即可，无需指定类型（这样还能减少依赖！）。你也可以保留名称，避免回收已删除的字段名：reserved &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;;。
要为已删除枚举值保留编号 当你删除一个不再使用的枚举值时，应该保留其编号，防止将来被误用。只需 reserved 2, 3; 即可。你也可以保留名称，避免回收已删除的值名：reserved &amp;quot;FOO&amp;quot;, &amp;quot;BAR&amp;quot;;。
要将新的枚举别名放在最后 添加新的枚举别名时，应将新名称放在最后，以便服务有时间更新。
如果要安全地移除原始名称（如果它被用于数据交换，实际上不推荐），你必须执行以下步骤：
在旧名称下方添加新名称，并弃用旧名称（序列化器仍会使用旧名称） 所有解析器都升级后，交换两个名称的顺序（序列化器开始使用新名称，解析器接受两者） 所有序列化器都升级后，可以删除已弃用的名称。 注意： 理论上客户端不应使用旧名称进行数据交换，但对于广泛使用的枚举名称，仍建议遵循上述步骤。
不要更改字段类型 几乎不要更改字段类型；这会导致反序列化出错，与重复使用标签号类似。 protobuf 文档 列举了极少数可以更改的情况（如 int32、uint32、int64 和 bool 之间）。但更改字段的消息类型会导致破坏，除非新消息是旧消息的超集。
不要添加必填字段 绝不要添加必填字段，建议用 // required 注释来说明 API 合约。必填字段被认为有害，已在 proto3 中完全移除。所有字段应为 optional 或 repeated。你无法预知消息类型会存在多久，也无法预知四年后某人是否被迫用空字符串或零来填充你定义的必填字段。
对于 proto3，没有 required 字段，因此此建议不适用。
不要创建包含大量字段的消息 不要创建包含“很多”（比如上百个）字段的消息。在 C++ 中，每个字段无论是否被赋值，都会增加大约 65 位的内存占用（8 字节指针，如果声明为 optional，还会有一个位用于标记是否被赋值）。当 proto 过大时，生成的代码甚至可能无法编译（例如 Java 对方法大小有限制）。
要在枚举中包含未指定值 枚举应在声明的第一个值中包含默认的 FOO_UNSPECIFIED。当 proto2 枚举添加新值时，旧客户端会将该字段视为未设置，getter 会返回默认值或第一个声明的值（如果没有默认值）。为保证与 proto 枚举 的一致性，第一个声明的枚举值应为默认的 FOO_UNSPECIFIED，且编号为 0。不要将默认值声明为有实际意义的值，这有助于协议随时间演进。所有声明在同一消息下的枚举值在 C++ 命名空间中相同，因此应使用枚举名作为前缀，避免编译错误。如果不需要跨语言常量，int32 能保留未知值且生成的代码更少。注意 proto 枚举 要求第一个值为 0，并且可以对未知枚举值进行序列化和反序列化。</description></item><item><title>避免盲目跟风</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/no-cargo-cults/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/no-cargo-cults/</guid><description>不要在 proto 文件中进行 盲目跟风 设置。如果你是基于现有的 schema 定义创建新的 proto 文件，除非你理解某个 option 设置的必要性，否则不要随意应用。
针对 Editions 的最佳实践 除非确有必要，避免在 .proto 文件中应用 editions 功能。 这些功能通常表示使用了实验性的未来行为或已弃用的过去行为。最新 edition 的最佳实践始终为默认。新的 proto schema 定义内容应保持无功能设置，除非你希望提前采用某个即将推出的功能。
在不了解设置原因的情况下复制功能设置，可能会导致代码出现意外行为。</description></item><item><title>API 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/api/</guid><description>已针对 proto3 更新。欢迎补丁！
本文档是 Proto 最佳实践 的补充。 它不是针对 Java/C++/Go 及其他 API 的规定。
如果你在代码评审中发现 proto 偏离了这些指南，请将作者指向本主题，帮助传播最佳实践。
注意 这些指南仅供参考，且许多有明确的例外。例如，如果你在编写性能关键的后端，可能会为了速度牺牲灵活性或安全性。本主题将帮助你更好地理解权衡，并做出适合你场景的决策。 精确、简明地为大多数字段和消息编写文档 你的 proto 很可能会被不了解你设计初衷的人继承和使用。请用对新团队成员或客户有用的术语为每个字段编写文档。
具体示例：
// 错误：启用 Foo 的选项 // 正确：控制 Foo 功能行为的配置。 message FeatureFooConfig { // 错误：设置是否启用该功能 // 正确：必填字段，指示是否为 account_id 启用 Foo 功能。 // 如果 account_id 的 FOO_OPTIN Gaia 位未设置，必须为 false。 optional bool enabled; } // 错误：Foo 对象。 // 正确：API 中面向客户端的 Foo（what/foo）表示。 message Foo { // 错误：foo 的标题。 // 正确：表示用户提供的 Foo 标题，无归一化或转义。 // 示例标题：&amp;#34;Picture of my cat in a box &amp;lt;3 &amp;lt;3 !</description></item><item><title>1-1-1 最佳实践</title><link>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/1-1-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/best-practices/1-1-1/</guid><description>1-1-1 最佳实践是尽可能将每个 proto_library 和 .proto 文件保持小巧，理想情况是：
一个 proto_library 构建规则 一个源 .proto 文件 一个顶级实体（消息、枚举或扩展） 尽可能减少消息、枚举、扩展和服务的数量可以使重构更容易。当文件分离时，移动文件比从包含其他消息的文件中提取消息更容易。
遵循此实践可以通过减少实际中传递依赖项的大小来帮助构建时间和二进制文件大小：当某些代码只需要使用一个枚举时，在 1-1-1 设计下，它可以仅依赖定义该枚举的 .proto 文件，而避免意外地引入可能仅被同一文件中定义的其他消息使用的大量传递依赖项。
在某些情况下，1-1-1 理想情况可能不可行（循环依赖）、不理想（极其概念上耦合的消息放在一起有助于可读性），或者某些缺点不适用（当 .proto 文件没有导入时，就没有关于传递依赖项大小的技术问题）。与任何最佳实践一样，请根据实际情况判断何时偏离该指南。
在创建 gRPC 定义时，proto 模式文件的模块化非常重要。以下是一组展示模块化结构的 proto 文件。
student_id.proto
edition = &amp;#34;2023&amp;#34;; package my.package; message StudentId { string value = 1; } full_name.proto
edition = &amp;#34;2023&amp;#34;; package my.package; message FullName { string family_name = 1; string given_name = 2; } student.proto
edition = &amp;#34;2023&amp;#34;; package my.package; import &amp;#34;student_id.proto&amp;#34;; import &amp;#34;full_name.</description></item><item><title>Protocol Buffer Basics: C++</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/cpptutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/cpptutorial/</guid><description>This tutorial provides a basic C++ programmers introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the C++ protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in C++. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the C++ API Reference, the C++ Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: C#</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/csharptutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/csharptutorial/</guid><description>This tutorial provides a basic C# programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the C# protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in C#. For more detailed reference information, see the Protocol Buffer Language Guide, the C# API Reference, the C# Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Dart</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/darttutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/darttutorial/</guid><description>This tutorial provides a basic Dart programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Dart protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Dart . For more detailed reference information, see the Protocol Buffer Language Guide, the Dart Language Tour, the Dart API Reference, the Dart Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Go</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/gotutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/gotutorial/</guid><description>This tutorial provides a basic Go programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Go protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Go. For more detailed reference information, see the Protocol Buffer Language Guide, the Go API Reference, the Go Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Java</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/javatutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/javatutorial/</guid><description>This tutorial provides a basic Java programmer&amp;rsquo;s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Java protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Java. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Java API Reference, the Java Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Kotlin</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/kotlintutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/kotlintutorial/</guid><description>This tutorial provides a basic Kotlin programmer&amp;rsquo;s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Kotlin protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Kotlin. For more detailed reference information, see the Protocol Buffer Language Guide, the Kotlin API Reference, the Kotlin Generated Code Guide, and the Encoding Reference.</description></item><item><title>Protocol Buffer Basics: Python</title><link>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/pythontutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/getting-started/pythontutorial/</guid><description>This tutorial provides a basic Python programmer&amp;rsquo;s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to
Define message formats in a .proto file. Use the protocol buffer compiler. Use the Python protocol buffer API to write and read messages. This isn&amp;rsquo;t a comprehensive guide to using protocol buffers in Python. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Python API Reference, the Python Generated Code Guide, and the Encoding Reference.</description></item><item><title>C++ Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/cpp-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/cpp-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler produces C++ output when invoked with the --cpp_out= command-line flag. The parameter to the --cpp_out= option is the directory where you want the compiler to write your C++ output.</description></item><item><title>String View APIs</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/string-view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/string-view/</guid><description>C++ string field APIs that use std::string significantly constrain the internal protobuf implementation and its evolution. For example, mutable_string_field() returns std::string* that forces us to use std::string to store the field. This complicates its interaction on arenas and we have to maintain arena donation states to track whether string payload allocation is from arena or heap.
Long-term, we would like to migrate all of our runtime and generated APIs to accept string_view as inputs and return them from accessors.</description></item><item><title>C++ Arena Allocation Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/arenas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/arenas/</guid><description>This page describes exactly what C++ code the protocol buffer compiler generates in addition to the code described in the C++ Generated Code Guide when arena allocation is enabled. It assumes that you are familiar with the material in the language guide and the C++ Generated Code Guide.
Why Use Arena Allocation? Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings.</description></item><item><title>Abseil Support</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/abseil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/abseil/</guid><description>In version 22.x, C++ protobuf added an explicit dependency on Abseil.
Bazel Support If you are using Bazel, to determine the version of Abseil that your protobuf version supports, you can use the bazel mod command:
$ bazel mod deps abseil-cpp --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) └───abseil-cpp@20240722.0 ├───bazel_skylib@1.7.1 ├───googletest@1.15.2 └───platforms@0.0.10 bazel mod graph produces the full output:
$ bazel mod graph --enable_bzlmod &amp;lt;root&amp;gt; (protobuf@30.0-dev) ├───abseil-cpp@20240722.0 │ ├───bazel_skylib@1.7.1 (*) │ ├───googletest@1.15.2 (*) │ └───platforms@0.</description></item><item><title>C++ API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs-link/</guid><description/></item><item><title>C# Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/csharp/csharp-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/csharp/csharp-generated/</guid><description>You should read the proto3 language guide before reading this document.
Note The protobuf compiler can generate C# interfaces for definitions using proto2 syntax starting from release 3.10. Refer to the proto2 language guide for details of the semantics of proto2 definitions, and see docs/csharp/proto2.md (view on GitHub) for details on the generated C# code for proto2. Compiler Invocation The protocol buffer compiler produces C# output when invoked with the --csharp_out command-line flag.</description></item><item><title>C# API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/csharp/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/csharp/api-docs-link/</guid><description/></item><item><title>Dart Generated Code</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/dart/dart-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/dart/dart-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler requires a plugin to generate Dart code. Installing it following the instructions provides a protoc-gen-dart binary which protoc uses when invoked with the --dart_out command-line flag.</description></item><item><title>Dart API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/dart/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/dart/api-docs-link/</guid><description/></item><item><title>Go 生成代码指南（Open）</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated/</guid><description>proto2 和 proto3 生成代码的差异已高亮标注——注意，这些差异仅体现在本文档描述的生成代码中，基础 API 在两个版本中是相同的。建议在阅读本文档前，先阅读 proto2 语言指南 和/或 proto3 语言指南。
注意 您正在查看旧版生成代码 API（Open Struct API）的文档。 参见 Go 生成代码（Opaque） 获取新版 Opaque API 的相关文档。Opaque API 的介绍请见 Go Protobuf: The new Opaque API。 编译器调用 Protocol Buffer 编译器需要插件来生成 Go 代码。使用 Go 1.16 或更高版本，运行以下命令安装：
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 这将在 $GOBIN 目录下安装 protoc-gen-go 可执行文件。可通过设置 $GOBIN 环境变量更改安装位置。该目录需加入您的 $PATH，以便编译器找到插件。
编译器通过 go_out 标志生成 Go 输出。该标志的参数为输出目录。每个输入的 .proto 文件会生成一个源文件，输出文件名将 .proto 后缀替换为 .pb.go。
生成的 .pb.go 文件在输出目录中的位置取决于编译器参数，有以下几种模式：
指定 paths=import 时，输出文件放在以 Go 包导入路径命名的目录下（如 .proto 文件中的 go_package 选项）。例如，输入文件 protos/buzz.</description></item><item><title>Go 生成代码指南（Opaque）</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated-opaque/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/go-generated-opaque/</guid><description>proto2 和 proto3 生成代码的任何差异都会被高亮标注——请注意，这些差异仅体现在本文档描述的生成代码中，基础 API 在两个版本中是相同的。建议在阅读本文档前，先阅读 proto2 语言指南 和/或 proto3 语言指南。
注意 您正在查看 Opaque API 的文档，这是当前版本。如果您正在处理使用旧版 Open Struct API 的 .proto 文件（可通过 .proto 文件中的 API level 设置判断），请参阅 Go 生成代码（Open） 获取相应文档。Opaque API 的介绍见 Go Protobuf: The new Opaque API。 编译器调用 Protocol Buffer 编译器需要插件来生成 Go 代码。使用 Go 1.16 或更高版本，运行以下命令安装：
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 这将在 $GOBIN 目录下安装 protoc-gen-go 二进制文件。通过设置 $GOBIN 环境变量可更改安装位置。该目录必须在您的 $PATH 中，以便编译器找到它。
编译器通过 go_out 标志生成 Go 输出。该标志的参数为您希望编译器写入 Go 输出的目录。每个输入的 .proto 文件会生成一个源文件，输出文件名为将 .proto 扩展名替换为 .</description></item><item><title>Go 常见问题</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/faq/</guid><description>版本 github.com/golang/protobuf 和 google.golang.org/protobuf 有什么区别？ github.com/golang/protobuf 模块是最初的 Go Protocol Buffers API。
google.golang.org/protobuf 模块是该 API 的更新版本，设计更简洁、易用且安全。新版 API 的主要特性包括反射支持，以及将用户接口与底层实现分离。
我们建议新代码使用 google.golang.org/protobuf。
github.com/golang/protobuf 的 v1.4.0 及更高版本会封装新实现，允许程序逐步采用新 API。例如，github.com/golang/protobuf/ptypes 中定义的知名类型只是新模块中类型的别名。因此，google.golang.org/protobuf/types/known/emptypb 和 github.com/golang/protobuf/ptypes/empty 可以互换使用。
什么是 proto1、proto2 和 proto3？ 这些是 Protocol Buffers 语言 的不同版本，与 Go 的 实现 无关。
proto3 是当前的语言版本，也是最常用的版本。我们建议新代码使用 proto3。 proto2 是较早的版本，虽然已被 proto3 取代，但仍然完全支持。 proto1 是已废弃的版本，从未开源。 有多个 Message 类型，我该用哪个？ &amp;quot;google.golang.org/protobuf/proto&amp;quot;.Message 是当前 Protocol Buffers 编译器生成的所有消息实现的接口类型。用于操作任意消息的函数（如 proto.Marshal 或 proto.Clone）接受或返回此类型。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.Message 是描述消息反射视图的接口类型。
可通过 proto.Message 的 ProtoReflect 方法获得 protoreflect.Message。
&amp;quot;google.golang.org/protobuf/reflect/protoreflect&amp;quot;.ProtoMessage 是 &amp;quot;google.</description></item><item><title>Go Size 语义</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/size/</guid><description>proto.Size 函数通过遍历 proto.Message 的所有字段（包括子消息），返回其线格式编码的字节大小。
特别地，它返回的是Go Protobuf 如何编码该消息时的大小。
典型用法 判断消息是否为空 检查 proto.Size 是否返回 0， 是识别空消息的简单方法：
if proto.Size(m) == 0 { // 没有设置字段（或在 proto3 中，所有字段都为默认值）； // 跳过处理该消息，或返回错误等。 } 限制程序输出的大小 假设你正在编写一个批处理管道，用于生成工作任务，交给下游系统处理。 下游系统适合处理小到中等规模的任务，但负载测试显示，当任务超过 500 MB 时， 系统会出现级联故障。
最佳做法是为下游系统增加保护（参见 https://cloud.google.com/blog/products/gcp/using-load-shedding-to-survive-a-success-disaster-cre-life-lessons）， 但如果无法实现负载卸载，可以在管道中添加一个快速修复：
func (*beamFn) ProcessElement(key string, value []byte, emit func(proto.Message)) { task := produceWorkTask(value) if proto.Size(task) &amp;gt; 500 * 1024 * 1024 { // 跳过所有超过 500 MB 的任务，避免压垮脆弱的下游系统。 return } emit(task) } 错误用法：与 Unmarshal 无关 由于 proto.</description></item><item><title>Go API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/api-docs-link/</guid><description/></item><item><title>Java Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/java-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/java-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Note that no Java protocol buffer methods accept or return nulls unless otherwise specified.
Compiler Invocation The protocol buffer compiler produces Java output when invoked with the --java_out= command-line flag.</description></item><item><title>Go Opaque API 迁移</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration/</guid><description>Opaque API 是 Protocol Buffers 针对 Go 编程语言的最新实现版本。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: Releasing the Opaque API 博客文章以了解介绍。
迁移到 Opaque API 是逐步进行的，可以按每个 proto 消息或每个 .proto 文件进行，通过设置 Protobuf Editions 功能的 api_level 选项为以下值之一：
API_OPEN 选择 Open Struct API；这是 2024 年 12 月之前的唯一 API。 API_HYBRID 是 Open 和 Opaque 之间的过渡：Hybrid API 也包含访问器方法（便于你更新代码），但仍然像以前一样导出结构体字段。性能没有差异；此 API 级别仅用于迁移。 API_OPAQUE 选择 Opaque API。 目前，默认值为 API_OPEN，但即将发布的 Protobuf Edition 2024 将默认值更改为 API_OPAQUE。
要在 Edition 2024 之前使用 Opaque API，请如下设置 api_level：
edition = &amp;#34;2023&amp;#34;; package log; import &amp;#34;google/protobuf/go_features.</description></item><item><title>Java Proto Names</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/java-proto-names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/java-proto-names/</guid><description>This document contains information on what the fully-qualified Java name of a proto is, based on the different proto options. This name corresponds to the package you need to import to use that message.
Recommendation Set option java_multiple_files = true; Set option java_outer_classname = &amp;quot;FileNameProto&amp;quot;; Set option java_package = &amp;quot;com.google.package&amp;quot;; Explanation Multiple Files With java_multiple_files = true, the generated Java class for each message will be placed in a separate .</description></item><item><title>Java API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/java/api-docs-link/</guid><description/></item><item><title>Go Opaque API：手动迁移</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration-manual/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-migration-manual/</guid><description>Opaque API 是 Protocol Buffers 在 Go 语言中的最新实现。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: Releasing the Opaque API 博客文章以了解简介。
本文档为将 Go Protobuf 用法从旧的 Open Struct API 迁移到新的 Opaque API 的用户指南。
警告 您正在查看手动迁移指南。通常建议使用 open2opaque 工具自动迁移。请参阅 Opaque API 迁移 获取更多信息。 生成代码指南 提供了更多细节。本文将新旧 API 进行对比。
消息构造 假设有如下 protobuf 消息定义：
message Foo { uint32 uint32 = 1; bytes bytes = 2; oneof union { string string = 4; MyMessage message = 5; } enum Kind { … }; Kind kind = 9; } 以下是如何从字面值构造该消息的示例：</description></item><item><title>Go Opaque API 常见问题解答</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/go/opaque-faq/</guid><description>Opaque API 是 Protocol Buffers 针对 Go 语言实现的最新版本。旧版本现在称为 Open Struct API。请参阅 Go Protobuf: The new Opaque API 博客文章以了解介绍。
本常见问题解答回答了关于新 API 及迁移过程中的常见问题。
创建新的 .proto 文件时应使用哪个 API？ 我们建议新开发选择 Opaque API。Protobuf Edition 2024（参见 Protobuf Editions 概览）将使 Opaque API 成为默认选项。
如何为我的消息启用新的 Opaque API？ 在 Protobuf Edition 2023（撰写时为当前版本）中，可以通过在 .proto 文件中将 api_level editions 特性设置为 API_OPAQUE 来选择 Opaque API。可以按文件或按消息设置：
edition = &amp;#34;2023&amp;#34;; package log; import &amp;#34;google/protobuf/go_features.proto&amp;#34;; option features.(pb.go).api_level = API_OPAQUE; message LogEntry { … } Protobuf Edition 2024 将默认使用 Opaque API，届时无需额外导入或选项：</description></item><item><title>Kotlin Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/kotlin-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/kotlin-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler Invocation The protocol buffer compiler produces Kotlin code that builds on top of Java code. As a result, it must be invoked with two command-line flags, --java_out= and --kotlin_out=.</description></item><item><title>Objective-C Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/objective-c/objective-c-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/objective-c/objective-c-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Compiler invocation The protocol buffer compiler produces Objective-C output when invoked with the --objc_out= command-line flag. The parameter to the --objc_out= option is the directory where you want the compiler to write your Objective-C output. The compiler creates a header file and an implementation file for each .</description></item><item><title>PHP Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/php/php-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/php/php-generated/</guid><description>You should read the proto3 language guide before reading this document. Note that the protocol buffer compiler currently only supports proto3 code generation for PHP.
Compiler Invocation The protocol buffer compiler produces PHP output when invoked with the --php_out= command-line flag. The parameter to the --php_out= option is the directory where you want the compiler to write your PHP output. In order to conform to PSR-4, the compiler creates a sub-directory corresponding to the package defined in the proto file.</description></item><item><title>PHP API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/php/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/php/api-docs-link/</guid><description/></item><item><title>Python Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/python/python-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/python/python-generated/</guid><description>Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.
The Python Protocol Buffers implementation is a little different from C++ and Java. In Python, the compiler only outputs code to build descriptors for the generated classes, and a Python metaclass does the real work.</description></item><item><title>Python API</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/python/api-docs-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/python/api-docs-link/</guid><description/></item><item><title>Ruby Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/ruby/ruby-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/ruby/ruby-generated/</guid><description>You should read the language guides for proto2 or proto3 before reading this document.
The protocol compiler for Ruby emits Ruby source files that use a DSL to define the message schema. However the DSL is still subject to change. In this guide we only describe the API of the generated messages, and not the DSL.
Compiler Invocation The protocol buffer compiler produces Ruby output when invoked with the --ruby_out= command-line flag.</description></item><item><title>Rust Generated Code Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-generated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-generated/</guid><description>This page describes exactly what Rust code the protocol buffer compiler generates for any given protocol definition.
Any differences between proto2 and proto3 generated code are highlighted. You should read the proto2 language guide and/or proto3 language guide before reading this document.
Protobuf Rust Protobuf Rust is an implementation of protocol buffers designed to be able to sit on top of other existing protocol buffer implementations that we refer to as &amp;lsquo;kernels&amp;rsquo;.</description></item><item><title>Redaction in Rust</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-redaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-redaction/</guid><description>Use the standard fmt::Debug (&amp;quot;{:?}&amp;quot; in format strings) on Protobuf messages for human-readable strings for logging, error messages, exceptions, and similar use cases. The output of this debug info is not intended to be machine-readable (unlike TextFormat and JSON which are not be used for debug output).
Using fmt::Debug enables redaction of some sensitive fields.
Note that under upb kernel this redaction is not yet implemented, but is expected to be added.</description></item><item><title>Building Rust Protos</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/building-rust-protos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/building-rust-protos/</guid><description>The process of building a Rust library for a Protobuf definition is similar to other programming languages:
Use the language-agnostic proto_library rule:
proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) Create a Rust library:
load(&amp;#34;//third_party/protobuf/rust:defs.bzl&amp;#34;, &amp;#34;rust_proto_library&amp;#34;) proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.proto&amp;#34;], ) rust_proto_library( name = &amp;#34;person_rust_proto&amp;#34;, deps = [&amp;#34;:person_proto&amp;#34;], ) Use the library by including it in a Rust binary:
load(&amp;#34;//third_party/bazel_rules/rules_rust/rust:defs.bzl&amp;#34;, &amp;#34;rust_binary&amp;#34;) load(&amp;#34;//third_party/protobuf/rust:defs.bzl&amp;#34;, &amp;#34;rust_proto_library&amp;#34;) proto_library( name = &amp;#34;person_proto&amp;#34;, srcs = [&amp;#34;person.</description></item><item><title>Rust Proto Design Decisions</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-design-decisions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/rust/rust-design-decisions/</guid><description>As with any library, Rust Protobuf is designed considering the needs of both Google&amp;rsquo;s first-party usage of Rust as well that of external users. Choosing a path in that design space means that some choices made will not be optimal for some users in some cases, even if it is the right choice for the implementation overall.
This page covers some of the larger design decisions that the Rust Protobuf implementation makes and the considerations which led to those decisions.</description></item><item><title>Protocol Buffers Edition 2023 Language Specification</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/edition-2023-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/edition-2023-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; capitalLetter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; ... &amp;#34;F&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;f&amp;#34; Identifiers ident = letter { letter | decimalDigit | &amp;#34;_&amp;#34; } fullIdent = ident { &amp;#34;.</description></item><item><title>Protocol Buffers Version 2 Language Specification</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/proto2-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/proto2-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto2, see the language guide.
Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; capitalLetter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; .</description></item><item><title>Protocol Buffers Version 3 Language Specification</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/proto3-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/proto3-spec/</guid><description>The syntax is specified using Extended Backus-Naur Form (EBNF):
| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto3, see the language guide.
Lexical Elements Letters and Digits letter = &amp;#34;A&amp;#34; ... &amp;#34;Z&amp;#34; | &amp;#34;a&amp;#34; ... &amp;#34;z&amp;#34; decimalDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; octalDigit = &amp;#34;0&amp;#34; ... &amp;#34;7&amp;#34; hexDigit = &amp;#34;0&amp;#34; ... &amp;#34;9&amp;#34; | &amp;#34;A&amp;#34; ... &amp;#34;F&amp;#34; | &amp;#34;a&amp;#34; .</description></item><item><title>Text Format Language Specification</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/textformat-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/textformat-spec/</guid><description>This format is distinct from the format of text within a .proto schema, for example. This document contains reference documentation using the syntax specified in ISO/IEC 14977 EBNF.
Note This is a draft spec reverse-engineered from the C++ text format implementation and may change based on further discussion and review. While an effort has been made to keep text formats consistent across supported languages, incompatibilities are likely to exist. Example convolution_benchmark { label: &amp;#34;NHWC_128x20x20x56x160&amp;#34; input { dimension: [128, 56, 20, 20] data_type: DATA_HALF format: TENSOR_NHWC } } Parsing Overview The language elements in this spec are split into lexical and syntactic categories.</description></item><item><title>Protocol Buffers Well-Known Types</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/google.protobuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/protobuf/google.protobuf/</guid><description>Index Any (message) Api (message) BoolValue (message) BytesValue (message) DoubleValue (message) Duration (message) Empty (message) Enum (message) EnumValue (message) Field (message) Field.Cardinality (enum) Field.Kind (enum) FieldMask (message) FloatValue (message) Int32Value (message) Int64Value (message) ListValue (message) Method (message) Mixin (message) NullValue (enum) Option (message) SourceContext (message) StringValue (message) Struct (message) Syntax (enum) Timestamp (message) Type (message) UInt32Value (message) UInt64Value (message) Value (message) Well-Known Types that end in &amp;ldquo;Value&amp;rdquo; are wrapper messages for other types, such as BoolValue and EnumValue.</description></item><item><title>其他语言</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/other/</guid><description>当前版本已包含对 C++、Java、Go、Ruby、C# 和 Python 的编译器和 API，但编译器代码的设计使得添加对其他语言的支持变得容易。社区中有多个项目正在为 Protocol Buffers 添加新的语言实现，包括 C、Haskell、Perl、Rust 等。
我们已知的相关项目列表请参见 第三方插件 wiki 页面。
编译器插件 protoc（Protocol Buffers 编译器）可以通过插件扩展以支持新语言。插件其实就是一个程序，它从标准输入读取 CodeGeneratorRequest 协议缓冲区，然后将 CodeGeneratorResponse 协议缓冲区写入标准输出。这些消息类型定义在 plugin.proto 中。我们建议所有第三方代码生成器都作为插件编写，这样所有生成器都能提供一致的接口并共享同一个解析器实现。
插件可以用任何编程语言编写，但 Google 官方插件是用 C++ 实现的。如果你要编写自己的插件，使用 C++ 可以方便地参考这些示例并复用相关工具。
此外，插件还可以向其他代码生成器生成的文件中插入代码。有关“插入点”的更多信息，请参见 plugin.proto 中的注释。例如，你可以编写一个插件，为特定的 RPC 系统生成定制的 RPC 服务代码。每种语言生成的代码所支持的插入点，请参见相应的文档。</description></item><item><title>Version Support</title><link>https://astro-xao.github.io/protocolbuffers.github.io/support/version-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/support/version-support/</guid><description>Support windows for protoc and the various languages are covered in the tables later in this topic. Version numbers throughout this topic use SemVer conventions; in the version &amp;ldquo;3.21.7,&amp;rdquo; we say that &amp;ldquo;3&amp;rdquo; is the major version, &amp;ldquo;21&amp;rdquo; is the minor version, and &amp;ldquo;7&amp;rdquo; is the micro or patch number.
Starting with the v20.x protoc release, we changed our versioning scheme to enable nimbler updates to language-specific parts of Protocol Buffers.</description></item><item><title>Migration Guide</title><link>https://astro-xao.github.io/protocolbuffers.github.io/support/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/support/migration/</guid><description>Changes in v30.0 The following is a list of the breaking changes made to versions of the libraries, and how to update your code to accommodate the changes.
This covers breaking changes announced in News Announcements for v30.x and Release Notes for v30.0.
Replaced CMake Submodules with Fetched Deps Previously, our default CMake behavior was to use Git submodules to grab pinned dependencies. Specifying -Dprotobuf_ABSL_PROVIDER=package would flip our CMake configs to look for local installations of Abseil (with similar options for jsoncpp and gtest).</description></item><item><title>Cross-Version Runtime Guarantee</title><link>https://astro-xao.github.io/protocolbuffers.github.io/support/cross-version-runtime-guarantee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/support/cross-version-runtime-guarantee/</guid><description>Protobuf language bindings have two components. The generated code (typically produced from protoc) and the runtime libraries that must be included when using the generated code. When these come from different releases of protobuf, we are in a &amp;ldquo;cross version runtime&amp;rdquo; situation.
We intend to offer the following guarantees across all languages except C++ and Rust. These are the default guarantees; however, owners of protobuf code generators and runtimes may explicitly override them with more specific guarantees for that language.</description></item><item><title>Downloads</title><link>https://astro-xao.github.io/protocolbuffers.github.io/downloads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/downloads/</guid><description>Release Packages Latest Version The latest release of Protocol Buffers can be found on the release page.
Old Versions Older versions are available in our historical releases on GitHub.
Source Code GitHub Repository Protocol Buffers source code is hosted on GitHub.</description></item><item><title>History</title><link>https://astro-xao.github.io/protocolbuffers.github.io/history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/history/</guid><description>Understanding why protobuf was created and the decisions that changed it over time can help you to better use the features of the tool.
Why Did You Release Protocol Buffers? There are several reasons that we released Protocol Buffers.
Protocol buffers are used by many projects inside Google. We had other projects we wanted to release as open source that use protocol buffers, so to do this, we needed to release protocol buffers first.</description></item><item><title>Forum</title><link>https://astro-xao.github.io/protocolbuffers.github.io/forum-link/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/forum-link/</guid><description/></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/navbar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/navbar/</guid><description> Home Programming Guides Codelabs Reference</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/DslList
DslList [JVM] Content fun &amp;lt;E&amp;gt; DslList(delegate: List&amp;lt;E&amp;gt;)</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/iterator
iterator [JVM] Content open operator override fun iterator(): Iterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/listIterator
listIterator [JVM] Content open override fun listIterator(): ListIterator&amp;lt;E&amp;gt; open override fun listIterator(index: Int): ListIterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslList/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/DslMap
DslMap [JVM] Content fun &amp;lt;K, V&amp;gt; DslMap(delegate: Map&amp;lt;K, V&amp;gt;)</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/entries
entries [JVM] Content open override val entries: Set&amp;lt;Map.Entry&amp;lt;K, V&amp;raquo;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/keys
keys [JVM] Content open override val keys: Set&amp;lt;K&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/values
values [JVM] Content open override val values: Collection&amp;lt;V&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/ExtensionList
ExtensionList [JVM] Content fun &amp;lt;E, M : MessageLite&amp;gt; ExtensionList(extension: ExtensionLite&amp;lt;M, List&amp;lt;E&amp;raquo;, delegate: List&amp;lt;E&amp;gt;)</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/equals
equals [JVM] Content open operator override fun equals(other: Any?): Boolean</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/extension
extension [JVM] Content val extension: ExtensionLite&amp;lt;M, List&amp;lt;E&amp;raquo;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/hashCode
hashCode [JVM] Content open override fun hashCode(): Int</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/iterator
iterator [JVM] Content open operator override fun iterator(): Iterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/listIterator
listIterator [JVM] Content open override fun listIterator(): ListIterator&amp;lt;E&amp;gt; open override fun listIterator(index: Int): ListIterator&amp;lt;E&amp;gt;</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/toString
toString [JVM] Content open override fun toString(): String</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProtoCode/OnlyForUseByGeneratedProtoCode
OnlyForUseByGeneratedProtoCode [JVM] Content fun OnlyForUseByGeneratedProtoCode()</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker/ProtoDslMarker
ProtoDslMarker [JVM] Content fun ProtoDslMarker()</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/contains
contains [JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder&amp;lt;M&amp;raquo; MorBT.contains(extension: ExtensionLite&amp;lt;M, *&amp;gt;): Boolean
Returns true if the specified extension is set on this builder.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/get
get [JVM] Content operator fun ByteString.get(index: Int): Byte
Gets the byte at index.
[JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder&amp;lt;M&amp;gt;, T : Any&amp;gt; MorBT.get(extension: ExtensionLite&amp;lt;M, T&amp;gt;): T
Gets the current value of the proto extension.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/isA
isA [JVM] Content inline fun &amp;lt;T : Message&amp;gt; Any.isA(): Boolean
Returns true if this com.google.protobuf.Any contains a message of type T.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/plus
plus [JVM] Content operator fun ByteString.plus(other: ByteString): ByteString \
Concatenates the given ByteString to this one.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/set
set [JVM] Content operator fun &amp;lt;M : GeneratedMessageV3.ExtendableMessage&amp;lt;M&amp;gt;, B : GeneratedMessageV3.ExtendableBuilder&amp;lt;M, B&amp;gt;, T : Any&amp;gt; B.set(extension: ExtensionLite&amp;lt;M, T&amp;gt;, value: T)
Sets the current value of the proto extension in this builder.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/toByteStringUtf8
toByteStringUtf8 [JVM] Content fun String.toByteStringUtf8(): ByteString
Encodes this String into a sequence of UTF-8 bytes and returns the result as a ByteString.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/toByteString
toByteString [JVM] Content fun ByteArray.toByteString(): ByteString
Returns a copy of this ByteArray as an immutable ByteString.
[JVM] Content fun ByteBuffer.toByteString(): ByteString
Copies the remaining bytes from this ByteBuffer to a ByteString.</description></item><item><title/><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack/</guid><description>//protobuf-kotlin/com.google.protobuf.kotlin/unpack
unpack [JVM] Content inline fun &amp;lt;T : Message&amp;gt; Any.unpack(): T
Returns the message of type T encoded in this com.google.protobuf.Any.
Throws | | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash; InvalidProtocolBufferException | if this com.google.protobuf.Any does not contain a T message.</description></item><item><title>Changes announced April 11, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-11/</guid><description>Syntax Reflection Deprecation v23 will deprecate the ability to check syntax version using reflection. The deprecation will be included as warnings at build time. The capability will be removed in a future release.
Adding support for ctype=CORD in C++ v23 will add ctype=CORD support for singular bytes fields, including oneof fields, to specify that data should be stored using absl::cord instead of string. Support may be added in future releases for singular string field types and for repeated string and byte fields if there is enough interest from the open source community.</description></item><item><title>Changes announced April 20, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-20/</guid><description>Changes to Ruby Generator This GitHub PR, which will appear in the 23.x release, changes the Ruby code generator to emit a serialized proto instead of the DSL.
It removes the DSL from the code generator in anticipation of splitting the DSL out into a separate package.
Given a .proto file like:
syntax = &amp;#34;proto3&amp;#34;; package pkg; message TestMessage { optional int32 i32 = 1; optional TestMessage msg = 2; } Generated code before:</description></item><item><title>Changes announced April 28, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-28/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-04-28/</guid><description>Stricter validation for json_name v24 will forbid embedded null characters in the json_name field option. Going forward, any valid Unicode characters will be accepted, except \u0000. Null will still be allowed in field values.
Previously, the proto compiler allowed null characters, but support for this was inconsistent across languages and implementations. To fix this, we are clarifying the spec to say that null is not allowed in json_name, and will be rejected by the compiler.</description></item><item><title>Changes Announced on August 15, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-08-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-08-15/</guid><description>Python Breaking Change In v25 message.UnknownFields() will be deprecated in pure Python and C++ extensions. It will be removed in v26. Use the new UnknownFieldSet(message) support in unknown_fields.py as a replacement.</description></item><item><title>Changes announced August 3, 2022</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-08-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-08-03/</guid><description>This topic covers two areas: general platform support changes, and C++-specific changes that are being considered for the 22.x release line.
Platform Support Changes We&amp;rsquo;ve added guidance about the platforms that we support in this section of the documentation. The section currently covers C++ and PHP, but may be expanded with information about other platforms in the future.
Official C++ Support Matrix With the policy, mentioned earlier in this announcement, of using Google&amp;rsquo;s official foundational C++ support policy, our C++ compiler and toolchain support matrix will change.</description></item><item><title>Changes Announced on August 9, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-08-09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-08-09/</guid><description>.NET support policy The Protobuf team supports .NET in two ways:
Generation of C# code by protoc The Google.Protobuf NuGet package, which provides runtime support for the generated code, as well as reflection and other facilities The support policy for these has previously been unclear, particularly in terms of which .NET runtimes are supported. From August 2023 onwards, support will be provided in accordance with the Google Open Source support policy for .</description></item><item><title>arena.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.arena/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.arena/</guid><description>#include &amp;lt;google/protobuf/arena.h&amp;gt;
namespace google::protobuf
This file defines an Arena allocator for better allocation performance. Classes in this fileArenaOptionsArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. ArenaArena allocator. Arena::InternalHelperArena::is_arena_constructableHelper typetraits that indicates support for arenas in a type T at compile time. Arena::is_destructor_skippablestruct ArenaOptions#include &amp;lt;google/protobuf/arena.h&amp;gt;
namespace google::protobuf
ArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. Memberssize_tstart_block_sizeThis defines the size of the first block requested from the system malloc.</description></item><item><title>common.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.common/</guid><description>#include &amp;lt;google/protobuf/stubs/common.h&amp;gt;
namespace google::protobuf
Contains basic types and utilities used by the rest of the library. Classes in this file</description></item><item><title>code_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.code_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.code_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/code_generator.h&amp;gt;
namespace google::protobuf::compiler
Defines the abstract interface implemented by each of the language-specific code generators. Classes in this fileCodeGeneratorThe abstract interface to a class which generates code implementing a particular proto file in a particular language. GeneratorContextCodeGenerators generate one or more files in a given directory. File MembersThese definitions are not part of any class.typedefGeneratorContext OutputDirectoryThe type GeneratorContext was once called OutputDirectory. more...voidParseGeneratorParameter(const std::string &amp;amp; , std::vector&amp;lt; std::pair&amp;lt; std::string, std::string &amp;gt; &amp;gt; * )Several code generators treat the parameter argument as holding a list of options separated by commas.</description></item><item><title>command_line_interface.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface/</guid><description>#include &amp;lt;google/protobuf/compiler/command_line_interface.h&amp;gt;
namespace google::protobuf::compiler
Implements the Protocol Compiler front-end such that it may be reused by custom compilers written to support other languages. Classes in this fileCommandLineInterfaceThis class implements the command-line interface to the protocol compiler. class CommandLineInterface#include &amp;lt;google/protobuf/compiler/command_line_interface.h&amp;gt;
namespace google::protobuf::compiler
This class implements the command-line interface to the protocol compiler. It is designed to make it very easy to create a custom protocol compiler supporting the languages of your choice.</description></item><item><title>cpp_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/cpp/cpp_generator.h&amp;gt;
namespace google::protobuf::compiler::cpp
Generates C++ code for a given .proto file. Classes in this fileCppGeneratorCodeGenerator implementation which generates a C++ source file and header. class CppGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/cpp/cpp_generator.h&amp;gt;
namespace google::protobuf::compiler::cpp
CodeGenerator implementation which generates a C++ source file and header. If you create your own protocol compiler binary and you want it to support C++ output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>csharp_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/csharp/csharp_generator.h&amp;gt;
namespace google::protobuf::compiler::csharp
Generates C# code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation which generates a C# source file and header. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/csharp/csharp_generator.h&amp;gt;
namespace google::protobuf::compiler::csharp
CodeGenerator implementation which generates a C# source file and header. If you create your own protocol compiler binary and you want it to support C# output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>csharp_names.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.csharp_names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.csharp_names/</guid><description>#include &amp;lt;google/protobuf/compiler/csharp/csharp_names.h&amp;gt;
namespace google::protobuf::compiler::csharp
Provides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding C# class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringGetFileNamespace(const FileDescriptor * descriptor)Requires: more...std::stringGetClassName(const Descriptor * descriptor)Requires: more...std::stringGetReflectionClassName(const FileDescriptor * descriptor)Requires: more...std::stringGetOutputFile(const FileDescriptor * descriptor, const std::string file_extension, const bool generate_directories, const std::string base_namespace, std::string * error)Generates output file name for given file descriptor. more... std::string csharp::GetFileNamespace(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const FileDescriptor * descriptor)Requires: descriptor !</description></item><item><title>importer.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.importer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.importer/</guid><description>#include &amp;lt;google/protobuf/compiler/importer.h&amp;gt;
namespace google::protobuf::compiler
This file is the public interface to the .proto file parser. Classes in this fileSourceTreeDescriptorDatabaseAn implementation of DescriptorDatabase which loads files from a SourceTree and parses them. ImporterSimple interface for parsing .proto files. MultiFileErrorCollectorIf the importer encounters problems while trying to import the proto files, it reports them to a MultiFileErrorCollector. SourceTreeAbstract interface which represents a directory tree containing proto files. DiskSourceTreeAn implementation of SourceTree which loads files from locations on disk.</description></item><item><title>java_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.java_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.java_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/java/java_generator.h&amp;gt;
namespace google::protobuf::compiler::java
Generates Java code for a given .proto file. Classes in this fileJavaGeneratorCodeGenerator implementation which generates Java code. class JavaGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/java/java_generator.h&amp;gt;
namespace google::protobuf::compiler::java
CodeGenerator implementation which generates Java code. If you create your own protocol compiler binary and you want it to support Java output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersJavaGenerator()~JavaGenerator()implements CodeGeneratorvirtual boolGenerate(const FileDescriptor * file, const std::string &amp;amp; parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory.</description></item><item><title>java_names.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.java_names/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.java_names/</guid><description>#include &amp;lt;google/protobuf/compiler/java/java_names.h&amp;gt;
namespace google::protobuf::compiler::java
Provides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding Java class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringClassName(const Descriptor * descriptor)Requires: more...std::stringClassName(const EnumDescriptor * descriptor)Requires: more...std::stringClassName(const FileDescriptor * descriptor)Requires: more...std::stringClassName(const ServiceDescriptor * descriptor)Requires: more...std::stringFileJavaPackage(const FileDescriptor * descriptor)Requires: more...std::stringCapitalizedFieldName(const FieldDescriptor * descriptor)Requires: more... std::string java::ClassName(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const Descriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name.</description></item><item><title>javanano_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/javanano/javanano_generator.h&amp;gt;
namespace google::protobuf::compiler::javanano
Generates Java nano code for a given .proto file. Classes in this fileJavaNanoGeneratorCodeGenerator implementation which generates Java nano code. class JavaNanoGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/javanano/javanano_generator.h&amp;gt;
namespace google::protobuf::compiler::javanano
CodeGenerator implementation which generates Java nano code. If you create your own protocol compiler binary and you want it to support Java output for the nano runtime, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>js_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.js_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.js_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/js/js_generator.h&amp;gt;
namespace google::protobuf::compiler::js
Generates JavaScript code for a given .proto file. Classes in this fileGeneratorOptionsGeneratorCodeGenerator implementation which generates a JavaScript source file and header. struct GeneratorOptions#include &amp;lt;google/protobuf/compiler/js/js_generator.h&amp;gt;
namespace google::protobuf::compiler::js
MembersenumImportStyleWhat style of imports should be used. more...enumOutputMode more...std::stringoutput_dirOutput path. std::stringnamespace_prefixNamespace prefix. boolbinaryEnable binary-format support? enum google::protobuf::compiler::js::GeneratorOptions::ImportStyleimport_stylebooladd_require_for_enumsAdd a goog.requires() call for each enum type used. more...booltestonlySet this as a test-only module via goog.setTestOnly();. std::stringlibraryCreate a library with name &amp;lt;name&amp;gt;_lib.js rather than a separate .</description></item><item><title>objectivec_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_generator.h&amp;gt;
namespace google::protobuf::compiler::objectivec
Generates ObjectiveC code for a given .proto file. Classes in this fileObjectiveCGeneratorCodeGenerator implementation which generates a ObjectiveC source file and header. class ObjectiveCGenerator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_generator.h&amp;gt;
namespace google::protobuf::compiler::objectivec
CodeGenerator implementation which generates a ObjectiveC source file and header. If you create your own protocol compiler binary and you want it to support ObjectiveC output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>objectivec_helpers.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers/</guid><description>#include &amp;lt;google/protobuf/compiler/objectivec/objectivec_helpers.h&amp;gt;
namespace google::protobuf::compiler::objectivec
Helper functions for generating ObjectiveC code. Classes in this fileOptionsGenerator options (see objectivec_generator.cc for a description of each): TextFormatDecodeDataGenerate decode data needed for ObjC's GPBDecodeTextFormatName() to transform the input into the expected output. LineConsumerHelper for parsing simple files. ImportWriterHelper class for parsing framework import mappings and generating import statements. File MembersThese definitions are not part of any class.enumObjectiveCType more...enumFlagType more...const char *constProtobufLibraryFrameworkNameThe name the commonly used by the library when built as a framework.</description></item><item><title>parser.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.parser/</guid><description>#include &amp;lt;google/protobuf/compiler/parser.h&amp;gt;
namespace google::protobuf::compiler
Implements parsing of .proto files to FileDescriptorProtos. Classes in this fileParserImplements parsing of protocol definitions (such as .proto files). SourceLocationTableA table mapping (descriptor, ErrorLocation) pairs &amp;ndash; as reported by DescriptorPool when validating descriptors &amp;ndash; to line and column numbers within the original source code. class Parser#include &amp;lt;google/protobuf/compiler/parser.h&amp;gt;
namespace google::protobuf::compiler
Implements parsing of protocol definitions (such as .proto files). Note that most users will be more interested in the Importer class.</description></item><item><title>plugin.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.plugin/</guid><description>#include &amp;lt;google/protobuf/compiler/plugin.h&amp;gt;
namespace google::protobuf::compiler
Front-end for protoc code generator plugins written in C++. To implement a protoc plugin in C++, simply write an implementation of CodeGenerator, then create a main() function like: int main(int argc, char* argv[]) { MyCodeGenerator generator; return google::protobuf::compiler::PluginMain(argc, argv, &amp;amp;generator); } You must link your plugin against libprotobuf and libprotoc.
The core part of PluginMain is to invoke the given CodeGenerator on a CodeGeneratorRequest to generate a CodeGeneratorResponse.</description></item><item><title>plugin.pb.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb/</guid><description>#include &amp;lt;google/protobuf/compiler/plugin.pb.h&amp;gt;
namespace google::protobuf::compiler
API for protoc plugins.
This file defines a set of protocol message classes which make up the API to protoc code generator plugins. Plugins written in C++ should probably build on the API in plugin.h instead of dealing with the protobuf-level API, but plugins in other languages will need to deal with the raw messages as defined below.
The protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions.</description></item><item><title>python_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.python_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.python_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/python/python_generator.h&amp;gt;
namespace google::protobuf::compiler::python
Generates Python code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Python protocol buffer classes. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/python/python_generator.h&amp;gt;
namespace google::protobuf::compiler::python
CodeGenerator implementation for generated Python protocol buffer classes. If you create your own protocol compiler binary and you want it to support Python output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>ruby_generator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator/</guid><description>#include &amp;lt;google/protobuf/compiler/ruby/ruby_generator.h&amp;gt;
namespace google::protobuf::compiler::ruby
Generates Ruby code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Ruby protocol buffer classes. class Generator: public CodeGenerator#include &amp;lt;google/protobuf/compiler/ruby/ruby_generator.h&amp;gt;
namespace google::protobuf::compiler::ruby
CodeGenerator implementation for generated Ruby protocol buffer classes. If you create your own protocol compiler binary and you want it to support Ruby output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function.</description></item><item><title>descriptor.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor/</guid><description>#include &amp;lt;google/protobuf/descriptor.h&amp;gt;
namespace google::protobuf
This file contains classes which describe a type of protocol message. You can use a message's descriptor to learn at runtime what fields it contains and what the types of those fields are. The Message interface also allows you to dynamically access and modify individual fields by passing the FieldDescriptor of the field you are interested in.
Most users will not care about descriptors, because they will write code specific to certain protocol types and will simply use the classes generated by the protocol compiler directly.</description></item><item><title>descriptor.pb.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor.pb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor.pb/</guid><description>#include &amp;lt;google/protobuf/descriptor.pb.h&amp;gt;
namespace google::protobuf
Protocol buffer representations of descriptors.
This file defines a set of protocol message classes which represent the same information represented by the classes defined in descriptor.h. You can convert a FileDescriptorProto to a FileDescriptor using the DescriptorPool class. Thus, the classes in this file allow protocol type definitions to be communicated efficiently between processes.
The protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions.</description></item><item><title>descriptor_database.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor_database/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.descriptor_database/</guid><description>#include &amp;lt;google/protobuf/descriptor_database.h&amp;gt;
namespace google::protobuf
Interface for manipulating databases of descriptors. Classes in this fileDescriptorDatabaseAbstract interface for a database of descriptors. SimpleDescriptorDatabaseA DescriptorDatabase into which you can insert files manually. EncodedDescriptorDatabaseVery similar to SimpleDescriptorDatabase, but stores all the descriptors as raw bytes and generally tries to use as little memory as possible. DescriptorPoolDatabaseA DescriptorDatabase that fetches files from a given pool. MergedDescriptorDatabaseA DescriptorDatabase that wraps two or more others. class DescriptorDatabase#include &amp;lt;google/protobuf/descriptor_database.</description></item><item><title>dynamic_message.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.dynamic_message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.dynamic_message/</guid><description>#include &amp;lt;google/protobuf/dynamic_message.h&amp;gt;
namespace google::protobuf
Defines an implementation of Message which can emulate types which are not known at compile-time. Classes in this fileDynamicMessageFactoryConstructs implementations of Message which can emulate types which are not known at compile-time. DynamicMapSorterHelper for computing a sorted list of map entries via reflection. class DynamicMessageFactory: public MessageFactory#include &amp;lt;google/protobuf/dynamic_message.h&amp;gt;
namespace google::protobuf
Constructs implementations of Message which can emulate types which are not known at compile-time. Sometimes you want to be able to manipulate protocol types that you don't know about at compile time.</description></item><item><title>coded_stream.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.coded_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.coded_stream/</guid><description>#include &amp;lt;google/protobuf/io/coded_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the CodedInputStream and CodedOutputStream classes, which wrap a ZeroCopyInputStream or ZeroCopyOutputStream, respectively, and allow you to read or write individual pieces of data in various formats. In particular, these implement the varint encoding for integers, a simple variable-length encoding in which smaller numbers take fewer bytes.
Typically these classes will only be used internally by the protocol buffer library in order to encode and decode protocol buffers.</description></item><item><title>gzip_stream.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.gzip_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.gzip_stream/</guid><description>#include &amp;lt;google/protobuf/io/gzip_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the definition for classes GzipInputStream and GzipOutputStream. GzipInputStream decompresses data from an underlying ZeroCopyInputStream and provides the decompressed data as a ZeroCopyInputStream.
GzipOutputStream is an ZeroCopyOutputStream that compresses data to an underlying ZeroCopyOutputStream. Classes in this fileGzipInputStreamA ZeroCopyInputStream that reads compressed data through zlib. GzipOutputStreamGzipOutputStream::Optionsclass GzipInputStream: public ZeroCopyInputStream#include &amp;lt;google/protobuf/io/gzip_stream.h&amp;gt;
namespace google::protobuf::io
A ZeroCopyInputStream that reads compressed data through zlib. MembersenumFormatFormat key for constructor. more.</description></item><item><title>printer.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.printer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.printer/</guid><description>#include &amp;lt;google/protobuf/io/printer.h&amp;gt;
namespace google::protobuf::io
Utility class for writing text to a ZeroCopyOutputStream. Classes in this fileAnnotationCollectorRecords annotations about a Printer's output. AnnotationProtoCollectorRecords annotations about a Printer's output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. Printerclass AnnotationCollector#include &amp;lt;google/protobuf/io/printer.h&amp;gt;
namespace google::protobuf::io
Records annotations about a Printer's output. Known subclasses:
AnnotationProtoCollector&lt; AnnotationProto >Memberstypedefstd::pair&amp;lt; std::pair&amp;lt; size_t, size_t &amp;gt;, std::string &amp;gt; AnnotationAnnotation is a offset range and a payload pair.</description></item><item><title>tokenizer.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.tokenizer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.tokenizer/</guid><description>#include &amp;lt;google/protobuf/io/tokenizer.h&amp;gt;
namespace google::protobuf::io
Class for parsing tokenized text from a ZeroCopyInputStream. Classes in this fileErrorCollectorAbstract interface for an object which collects the errors that occur during parsing. TokenizerThis class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. Tokenizer::TokenStructure representing a token read from the token stream. File MembersThese definitions are not part of any class.typedefint ColumnNumberBy "column number", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes.</description></item><item><title>zero_copy_stream.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller.</description></item><item><title>zero_copy_stream_impl.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream_impl.h&amp;gt;
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are only included in the full (non-lite) protobuf library. These implementations include Unix file descriptors and C++ iostreams. See also: zero_copy_stream_impl_lite.h Classes in this fileFileInputStreamA ZeroCopyInputStream which reads from a file descriptor. FileOutputStreamA ZeroCopyOutputStream which writes to a file descriptor. IstreamInputStreamA ZeroCopyInputStream which reads from a C++ istream. OstreamOutputStreamA ZeroCopyOutputStream which writes to a C++ ostream.</description></item><item><title>zero_copy_stream_iml_lite.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/</guid><description>#include &amp;lt;google/protobuf/io/zero_copy_stream_impl_lite.h&amp;gt;
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the "lite" protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases.</description></item><item><title>map.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.map/</guid><description>#include &amp;lt;google/protobuf/map.h&amp;gt;
namespace google::protobuf
This file defines the map container and its helpers to support protobuf maps. The Map and MapIterator types are provided by this header file. Please avoid using other types defined here, unless they are public types within Map or MapIterator, such as Map::value_type. Classes in this fileMapPairThis is the class for Map's internal value_type. MapMap is an associative container type used to store protobuf map fields. Map::const_iteratorIterators.</description></item><item><title>message.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.message/</guid><description>#include &amp;lt;google/protobuf/message.h&amp;gt;
namespace google::protobuf
Defines Message, the abstract interface implemented by non-lite protocol message objects. Although it's possible to implement this interface manually, most users will use the protocol compiler to generate implementations.
Example usage:
Say you have a message defined as:
message Foo { optional string text = 1; repeated int32 numbers = 2; } Then, if you used the protocol compiler to generate a class from the above definition, you could use it like so:</description></item><item><title>message_lite.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.message_lite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.message_lite/</guid><description>#include &amp;lt;google/protobuf/message_lite.h&amp;gt;
namespace google::protobuf
Defines MessageLite, the abstract interface implemented by all (lite and non-lite) protocol message objects. Classes in this fileMessageLiteInterface to light weight protocol messages. File MembersThese definitions are not part of any class.voidShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files. more... void protobuf::ShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .</description></item><item><title>repeated_field.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.repeated_field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.repeated_field/</guid><description>#include &amp;lt;google/protobuf/repeated_field.h&amp;gt;
namespace google::protobuf
RepeatedField and RepeatedPtrField are used by generated protocol message classes to manipulate repeated fields. These classes are very similar to STL's vector, but include a number of optimizations found to be useful specifically in the case of Protocol Buffers. RepeatedPtrField is particularly different from STL vector as it manages ownership of the pointers that it contains.
Typically, clients should not need to access RepeatedField objects directly, but should instead use the accessor functions generated automatically by the protocol compiler.</description></item><item><title>service.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.service/</guid><description>#include &amp;lt;google/protobuf/service.h&amp;gt;
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection.</description></item><item><title>text_format.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.text_format/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.text_format/</guid><description>#include &amp;lt;google/protobuf/text_format.h&amp;gt;
namespace google::protobuf
Utilities for printing and parsing protocol messages in a human-readable, text-based format. Classes in this fileTextFormatThis class implements protocol buffer text format, colloquially known as text proto. TextFormat::BaseTextGeneratorTextFormat::FastFieldValuePrinterThe default printer that converts scalar values from fields into their string representation. TextFormat::FieldValuePrinterDeprecated: please use FastFieldValuePrinter instead. TextFormat::FinderInterface that Printers or Parsers can use to find extensions, or types referenced in Any messages. TextFormat::MessagePrinterTextFormat::ParseInfoTreeData structure which is populated with the locations of each field value parsed from the text.</description></item><item><title>unknown_field_set.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.unknown_field_set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.unknown_field_set/</guid><description>#include &amp;lt;google/protobuf/unknown_field_set.h&amp;gt;
namespace google::protobuf
Contains classes used to keep track of unrecognized fields seen while parsing a protocol message. Classes in this fileUnknownFieldSetAn UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. UnknownFieldRepresents one field in an UnknownFieldSet. UnknownField::LengthDelimitedclass UnknownFieldSet#include &amp;lt;google/protobuf/unknown_field_set.h&amp;gt;
namespace google::protobuf
An UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. Keeping track of these can be useful, especially in that they may be written if the message is serialized again without being cleared in between.</description></item><item><title>field_comparator.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.field_comparator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.field_comparator/</guid><description>#include &amp;lt;google/protobuf/util/field_comparator.h&amp;gt;
namespace google::protobuf::util
Defines classes for field comparison. Classes in this fileFieldComparatorBase class specifying the interface for comparing protocol buffer fields. SimpleFieldComparatorBasic implementation of FieldComparator. DefaultFieldComparatorclass FieldComparator#include &amp;lt;google/protobuf/util/field_comparator.h&amp;gt;
namespace google::protobuf::util
Base class specifying the interface for comparing protocol buffer fields. Regular users should consider using or subclassing DefaultFieldComparator rather than this interface. Currently, this does not support comparing unknown fields. Known subclasses:
SimpleFieldComparatorMembersenumComparisonResult more...FieldComparator()virtual ~FieldComparator()virtual ComparisonResultCompare(const Message &amp;amp; message_1, const Message &amp;amp; message_2, const FieldDescriptor * field, int index_1, int index_2, const util::FieldContext * field_context) = 0Compares the values of a field in two protocol buffer messages.</description></item><item><title>field_mask_util.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.field_mask_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.field_mask_util/</guid><description>#include &amp;lt;google/protobuf/util/field_mask_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the FieldMask well known type. Classes in this fileFieldMaskUtilFieldMaskUtil::MergeOptionsFieldMaskUtil::TrimOptionsclass FieldMaskUtil#include &amp;lt;google/protobuf/util/field_mask_util.h&amp;gt;
namespace google::protobuf::util
Membersstatic std::stringToString(const FieldMask &amp;amp; mask)Converts FieldMask to/from string, formatted by separating each path with a comma (e.g., "foo_bar,baz.quz"). static voidFromString(StringPiece str, FieldMask * out)template static voidFromFieldNumbers(const std::vector&amp;lt; int64_t &amp;gt; &amp;amp; field_numbers, FieldMask * out)Populates the FieldMask with the paths corresponding to the fields with the given numbers, after checking that all field numbers are valid.</description></item><item><title>json_util.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.json_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.json_util/</guid><description>#include &amp;lt;google/protobuf/util/json_util.h&amp;gt;
namespace google::protobuf::util
Utility functions to convert between protobuf binary format and proto3 JSON format. Classes in this fileJsonParseOptionsJsonPrintOptionsFile MembersThese definitions are not part of any class.typedefJsonPrintOptions JsonOptionsDEPRECATED. Use JsonPrintOptions instead. util::StatusMessageToJsonString(const Message &amp;amp; message, std::string * output, const JsonOptions &amp;amp; options)Converts from protobuf message to JSON and appends it to |output|. more...util::StatusMessageToJsonString(const Message &amp;amp; message, std::string * output)util::StatusJsonStringToMessage(StringPiece input, Message * message, const JsonParseOptions &amp;amp; options)Converts from JSON to protobuf message.</description></item><item><title>message_differencer.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.message_differencer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.message_differencer/</guid><description>#include &amp;lt;google/protobuf/util/message_differencer.h&amp;gt;
namespace google::protobuf::util
This file defines static methods and classes for comparing Protocol Messages. Aug. 2008: Added Unknown Fields Comparison for messages. Aug. 2009: Added different options to compare repeated fields. Apr. 2010: Moved field comparison to FieldComparator Sep. 2020: Added option to output map keys in path Classes in this fileMessageDifferencerA basic differencer that can be used to determine the differences between two specified Protocol Messages. MessageDifferencer::IgnoreCriteriaAbstract base class from which all IgnoreCriteria derive.</description></item><item><title>time_util.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.time_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.time_util/</guid><description>#include &amp;lt;google/protobuf/util/time_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the Timestamp and Duration well known types. Classes in this fileTimeUtilUtility functions for Timestamp and Duration. class TimeUtil#include &amp;lt;google/protobuf/util/time_util.h&amp;gt;
namespace google::protobuf::util
Utility functions for Timestamp and Duration. Membersconst int64_tkTimestampMinSeconds = = -62135596800LLThe min/max Timestamp/Duration values we support. more...const int64_tkTimestampMaxSeconds = = 253402300799LLFor "9999-12-31T23:59:59.999999999Z". const int64_tkDurationMinSeconds = = -315576000000LLconst int64_tkDurationMaxSeconds = = 315576000000LLstatic std::stringToString(const Timestamp &amp;amp; timestamp)Converts Timestamp to/from RFC 3339 date string format. more.</description></item><item><title>type_resolver.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.type_resolver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.type_resolver/</guid><description>#include &amp;lt;google/protobuf/util/type_resolver.h&amp;gt;
namespace google::protobuf::util
Defines a TypeResolver for the Any message. Classes in this fileTypeResolverAbstract interface for a type resolver. class TypeResolver#include &amp;lt;google/protobuf/util/type_resolver.h&amp;gt;
namespace google::protobuf::util
Abstract interface for a type resolver. Implementations of this interface must be thread-safe. MembersTypeResolver()virtual ~TypeResolver()virtual util::StatusResolveMessageType(const std::string &amp;amp; type_url, google::protobuf::Type * message_type) = 0Resolves a type url for a message type. virtual util::StatusResolveEnumType(const std::string &amp;amp; type_url, google::protobuf::Enum * enum_type) = 0Resolves a type url for an enum type.</description></item><item><title>type_resolver_util.h</title><link>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.type_resolver_util/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/reference/cpp/api-docs/google.protobuf.util.type_resolver_util/</guid><description>#include &amp;lt;google/protobuf/util/type_resolver_util.h&amp;gt;
namespace google::protobuf::util
Defines utilities for the TypeResolver. Classes in this fileFile MembersThese definitions are not part of any class.TypeResolver *NewTypeResolverForDescriptorPool(const std::string &amp;amp; url_prefix, const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. more... TypeResolver * util::NewTypeResolverForDescriptorPool(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const std::string &amp;amp; url_prefix,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. Caller takes ownership of the returned TypeResolver.</description></item><item><title>Changes announced on December 13, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-13/</guid><description>C++ Breaking Changes In v26, we are planning a major version bump for C++ as per our breaking changes policy and version support policy.
The following sections outline the set of breaking changes that we plan to include in the 26.0 release of protocol buffers. Note that plans can and do change. These are potential breaking changes to be aware of, but they may not happen in this particular release, or they may not happen at all.</description></item><item><title>Changes announced December 13, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-13/</guid><description>Removing a Reflection-related Function In v30.x, we are removing the following reflection-related function: MutableRepeatedFieldRef&amp;lt;T&amp;gt;::Reserve().
An upcoming performance improvement in RepeatedPtrField is incompatible with this API. The improvement is projected to accelerate repeated access to the elements of RepeatedPtrField, in particular and especially sequential access.</description></item><item><title>Changes announced December 18, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-18/</guid><description>Go Protobuf: The new Opaque API Back in March 2020, we released the google.golang.org/protobuf module, a major overhaul of the Go Protobuf API. This package introduced first-class support for reflection, a dynamicpb implementation and the protocmp package for easier testing.
That release introduced a new protobuf module with a new API. Today, we are releasing an additional API for generated code, meaning the Go code in the .pb.go files created by the protocol compiler (protoc).</description></item><item><title>Changes announced on December 27, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-27/</guid><description>Ruby Breaking Changes The following changes are planned for the 26.x line:
Fix RepeatedField#each_index to have the correct semantics. (#11767) Remove Ruby DSL and associated compatibility code, which will complete the migration announced in April. Message#to_h fixes: Remove unset oneof fields. (#6167) Remove unset sub-message fields Use message&amp;rsquo;s pool for encode_json/decode_json. Remove the deprecated syntax accessor, FileDescriptor.syntax and add semantic checks in its place: FieldDescriptor.has_presence to test if a field has presence.</description></item><item><title>Changes announced December 4, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-12-04/</guid><description>We are planning to modify the Protobuf debug APIs for C++ (including Protobuf AbslStringify, proto2::ShortFormat, proto2::Utf8Format, Message::DebugString, Message::ShortDebugString, Message::Utf8DebugString) in v30 to redact sensitive fields annotated by debug_redact; the outputs of these APIs will contain a per-process randomized prefix, and so will no longer be parseable by Protobuf TextFormat Parsers.
Motivation Currently Protobuf debug APIs print every field in a proto into human-readable formats. This may lead to privacy incidents where developers accidentally log Protobuf debug outputs containing sensitive fields.</description></item><item><title>Changes announced on December 5, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-12-05/</guid><description>Java Breaking Changes In v26, we are planning a major version bump for Java per our breaking changes policy and version support policy.
The following sections outline the set of breaking changes that we plan to include in the 26.0 release of protocol buffers. Note that plans can and do change. These are potential breaking changes to be aware of, but they may not happen in this particular release, or they may not happen at all.</description></item><item><title>Changes Announced on February 27, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-02-27/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-02-27/</guid><description>Dropping Ruby 2.7 Support As per our official Ruby support policy, we will be dropping support for Ruby 2.7 and lower on March 31, 2024. The minimum supported Ruby version will be 3.0.</description></item><item><title>Changes announced February 5, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-02-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-02-05/</guid><description>This topic covers breaking changes in Java, C++, and Python in the 26.x line.
JSON Formatter Option Changes Starting in the 26.x line, the JSON formatter option to print default-valued fields is replaced with a fixed way to handle proto2 and proto3 optional fields consistently.
Java: includingDefaultValueFields() is replaced with alwaysPrintFieldsWithNoPresence(). C++: always_print_default_values is replaced with always_print_fields_with_no_presence=True. Py: including_default_value_fields=True is replaced with always_print_fields_with_no_presence=True. The new flag behaves identically to the old flag on proto3 messages, but no longer applies to proto2 optional fields.</description></item><item><title>Changes announced January 23, 2025</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2025-01-23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2025-01-23/</guid><description>Poison Java gencode We are patching a change into the 25.x branch that will poison Java gencode that was created prior to the 3.21.7 release. We will then mark all versions of Java protobuf from 3.21.7 through 3.25.5 as vulnerable to the footmitten CVE.
After this change is patched in, protobuf will throw an UnsupportedOperationException from the makeExtensionsImmutable method unless you set the system property &amp;ldquo;-Dcom.google.protobuf.use_unsafe_pre22_gencode&amp;rdquo;. Using this system property can buy you some time if you can&amp;rsquo;t update your code immediately, but should be considered a short-term workaround.</description></item><item><title>Changes announced January 31, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-01-31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-01-31/</guid><description>This topic covers breaking changes in Python in the 26.x line.
Python Breaking Changes Removing setup.py and setup.cfg support from GitHub In the 26.x release, setup.py and setup.cfg will no longer be present in the python/ directory of the GitHub repository or GitHub release tarballs. This means it will no longer be possible to build a Python package directly from the GitHub repo or release tarball.
The Python source packages published on PyPI will continue to have a setup.</description></item><item><title>Changes announced January 5, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-01-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-01-05/</guid><description>This topic covers breaking changes in Ruby and Python in the 26.x line.
Ruby Breaking Changes Freeze Is Now Recursive in Ruby Starting in the 26.x line, when freeze is applied it will be applied recursively, affecting all sub-messages, maps, and repeated fields.
Python Breaking Changes Removing Deprecated APIs In the 26.x release, the following deprecated APIs will be removed:
AddFileDescriptor AddDescriptor AddEnumDescriptor AddExtensionDescriptor AddServiceDescriptor Rejecting Extend Repeated Field with None Iterable Starting in the 26.</description></item><item><title>Changes Announced on July 17, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-07-17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-07-17/</guid><description>Dropping Bazel 5.x Support As per our official support policy, we will be dropping support for Bazel 5.x and lower. This means the minimum supported Bazel version is 6.2.x.</description></item><item><title>Changes announced July 6, 2022</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-07-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-07-06/</guid><description>Library Breaking Change Policy Google released its OSS Library Breaking Change Policy, which some Google-sponsored open source projects have opted into. Protocol buffers has adopted this policy.</description></item><item><title>Changes Announced on July 6, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-07-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-07-06/</guid><description>Dropping PHP 7.x Support As per our official PHP support policy, we will be dropping support for PHP 7.4 and lower. This means the minimum supported PHP version is 8.0.
If you are running an older version of PHP, you can install a previous release of the protobuf PHP extension by running pecl install protobuf-3.23.3.
Dropping Ruby 2.6 Support As per our official Ruby support policy, we will be dropping support for Ruby 2.</description></item><item><title>Changes Announced on June 26, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-06-26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-06-26/</guid><description>Dropping Support for Building Protobuf Java from Source with Maven We are planning to drop support for building Protobuf Java OSS from source with the Maven build system in the Protobuf Java 4.28 release. This has been marked deprecated in the 4.27 release.
After this point, you can continue to use Bazel, or another build system, to build Protobuf. You can read more about building from source in the Protobuf Java README.</description></item><item><title>Changes Announced on June 29, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-06-29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-06-29/</guid><description>TL;DR: We are planning to release Protobuf Editions to the open source project in the second half of 2023. While there is no requirement to move from proto2/proto3 syntax to Editions syntax at initial release, we encourage you to plan a move in your software project&amp;rsquo;s future timeline.
Protobuf Editions Protobuf Editions replace the proto2 and proto3 designations that we have used for Protocol Buffers. Instead of adding syntax = &amp;quot;proto2&amp;quot; or syntax = &amp;quot;proto3&amp;quot; at the top of proto definition files, you use an edition number, such as edition = &amp;quot;2024&amp;quot;, to specify the default behaviors your file will have.</description></item><item><title>Changes Announced on March 18, 2025</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2025-03-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2025-03-18/</guid><description>Dropping Ruby 3.0 Support As per our official Ruby support policy, we will be dropping support for Ruby 3.0 and lower in Protobuf version 31, due to release in April, 2025. The minimum supported Ruby version will be 3.1.</description></item><item><title>Changes announced May 6, 2022</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-05-06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2022-05-06/</guid><description>Versioning We changed our versioning scheme to enable more-nimble updates to language-specific parts of Protocol Buffers. In the new scheme, each language has its own major version that can be incremented independently of other languages, as covered later in this topic with the Python release. The minor and patch versions, however, will remain coupled. This allows us to introduce breaking changes into some languages without requiring a bump of the major version in languages that do not experience a breaking change.</description></item><item><title>Changes Announced on November 7, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-11-07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-11-07/</guid><description>The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These are in addition to those mentioned in the News article from October 2.
These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item><item><title>Changes Announced on October 1, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-10-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-10-01/</guid><description>Bazel and Proto Rules There are upcoming changes to the way that Bazel will work for protobuf builds. These changes require awareness in the first stage, and action by project owners before the second stage.
Stage 1 With the release of Bazel 8, proto rules (proto_library, cc_proto_library, java_proto_library, java_lite_proto_library, and py_proto_library) will be removed from the Bazel project. The will be added to the Protocol Buffers project in v29. Bazel will be updated to automatically use the rules from the protobuf project, so the change is initially a no-op for project owners.</description></item><item><title>Changes announced on October 10, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-10-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-10-10/</guid><description>Protobuf Editions Features Documentation that introduces Protobuf Editions features is now available.</description></item><item><title>Changes Announced on October 2, 2024</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-10-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2024-10-02/</guid><description>The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.
Changes in C++ C++ will bump its major version from 5.29.x to 6.30.x.
Descriptor APIs v30 will update return types in descriptor (such as full_name) to be absl::string_view.</description></item><item><title>Search Results</title><link>https://astro-xao.github.io/protocolbuffers.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/search/</guid><description/></item><item><title>Changes announced on September 15, 2023</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-09-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/2023-09-15/</guid><description>μpb Moving to the Protobuf Git Repository Starting with the v25 release, μpb now lives in the protobuf repo instead of in its former location in a separate repo. All μpb development going forward will take place only in the new location.
The merger of the two repos will simplify and speed up our development process by removing the need to update pinned version dependencies between protobuf and μpb. Changes to μpb now take effect immediately in protobuf code and vice versa, without the need for a manual upgrade step.</description></item><item><title>News Announcements for Version 21.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v21/</guid><description>The following announcements are specific to Version 21.x. For information presented chronologically, see News.
Python Updates We made some changes in Python language support in Protocol Buffers. Version 4.21.0 is a new major version, following 3.20.1. The new version is based on the upb library, and offers significantly better parsing performance than previous releases, especially for large payloads. It also includes prebuilt binary modules for Apple silicon for increased performance without a manual build.</description></item><item><title>News Announcements for Version 22.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v22/</guid><description>The following announcements are specific to Version 22.x. For information presented chronologically, see News.
Changing Maven Release Candidate Artifact Names to Be More Idiomatic In 22.0 we plan to rename Maven artifacts to use “RC” instead of “rc-” as the release candidate prefix.
Adding an Abseil Dependency In order to reduce the Google vs. OSS differences between protobuf and to simplify our own project, we plan to take a formal dependency on Abseil.</description></item><item><title>News Announcements for Version 23.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v23/</guid><description>The following announcements are specific to Version 23.x. For information presented chronologically, see News.
Changes to Ruby Generator This GitHub PR, which will appear in the 23.x release, changes the Ruby code generator to emit a serialized proto instead of the DSL.
It removes the DSL from the code generator in anticipation of splitting the DSL out into a separate package.
Given a .proto file like:
syntax = &amp;#34;proto3&amp;#34;; package pkg; message TestMessage { optional int32 i32 = 1; optional TestMessage msg = 2; } Generated code before:</description></item><item><title>News Announcements for Version 24.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v24/</guid><description>The following announcements are specific to Version 24.x. For information presented chronologically, see News.
Stricter validation for json_name v24 will forbid embedded null characters in the json_name field option. Going forward, any valid Unicode characters will be accepted, except \u0000. Null will still be allowed in field values.
Previously, the proto compiler allowed null characters, but support for this was inconsistent across languages and implementations. To fix this, we are clarifying the spec to say that null is not allowed in json_name, and will be rejected by the compiler.</description></item><item><title>News Announcements for Version 25.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v25/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v25/</guid><description>The following announcements are specific to Version 25.x. For information presented chronologically, see News.
Python Breaking Change In v25 message.UnknownFields() will be deprecated in pure Python and C++ extensions. It will be removed in v26. Use the new UnknownFieldSet(message) support in unknown_fields.py as a replacement.
μpb Moving to the Protobuf Git Repository Starting with the v25 release, μpb now lives in the protobuf repo instead of in its former location in a separate repo.</description></item><item><title>News Announcements for Version 26.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v26/</guid><description>The following announcements are specific to Version 26.x. For information presented chronologically, see News.
General Changes JSON Formatter Option Changes Starting in the 26.x line, the JSON formatter option to print default-valued fields is replaced with a fixed way to handle proto2 and proto3 optional fields consistently.
Java: includingDefaultValueFields() is replaced with alwaysPrintFieldsWithNoPresence(). C++: always_print_default_values is replaced with always_print_fields_with_no_presence=True. Py: including_default_value_fields=True is replaced with always_print_fields_with_no_presence=True. The new flag behaves identically to the old flag on proto3 messages, but no longer applies to proto2 optional fields.</description></item><item><title>News Announcements for Version 29.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v29/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v29/</guid><description>The following announcements are specific to Version 29.x. For information presented chronologically, see News.
Bazel and Proto Rules There are upcoming changes to the way that Bazel will work for protobuf builds. These changes require awareness in the first stage, and action by project owners before the second stage.
Stage 1 With the release of Bazel 8, proto rules (proto_library, cc_proto_library, java_proto_library, java_lite_proto_library, and py_proto_library) will be removed from the Bazel project.</description></item><item><title>News Announcements for Version 30.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v30/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v30/</guid><description>The following announcements are specific to Version 30.x. For information presented chronologically, see News.
The following sections cover planned breaking changes in the v30 release, expected in 2025 Q1. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item><item><title>News Announcements for Version 31.x</title><link>https://astro-xao.github.io/protocolbuffers.github.io/news/v31/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astro-xao.github.io/protocolbuffers.github.io/news/v31/</guid><description>The following announcements are specific to Version 31.x. For information presented chronologically, see News.
The following sections cover planned breaking changes in the v31 release, expected in 2025 Q2. Also included are some changes that aren&amp;rsquo;t breaking but may require action on your part. These describe changes as we anticipate them being implemented, but due to the flexible nature of software some of these changes may not land or may vary from how they are described in this topic.</description></item></channel></rss>